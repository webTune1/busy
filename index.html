<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Arcade Hub — Bubble + Racing Demo</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#071029;
    --panel:#081426;
    --muted:#9fb0c7;
    --accent:#ffb86b;
    --danger:#ef4444;
    --success:#10b981;
    --glass: rgba(255,255,255,0.03);
    --card: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  }
  /* Page */
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;background:linear-gradient(180deg,#041026,#07112a);color:#e6eef8;-webkit-font-smoothing:antialiased}
  .app{max-width:1200px;margin:16px auto;padding:16px;border-radius:12px;background:var(--card);box-shadow:0 18px 50px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03)}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  .logo{display:flex;align-items:center;gap:10px}
  .logo .icon{width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,#ffb86b,#ff7b7b);display:flex;align-items:center;justify-content:center;font-weight:700;color:#081022}
  h1{margin:0;font-size:18px}
  .muted{color:var(--muted);font-size:13px}
  .layout{display:flex;gap:14px}
  .left{flex:1;min-width:320px}
  .right{width:320px}
  .panel{background:transparent;padding:12px;border-radius:12px}
  /* Canvas container */
  .gameWrap{position:relative;border-radius:12px;overflow:hidden;background:linear-gradient(180deg,#071822,#02121a);display:flex;align-items:center;justify-content:center;padding:12px}
  canvas{display:block;width:100%;height:auto;border-radius:8px;background:transparent}
  /* HUD */
  .hud{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
  .stat{background:rgba(255,255,255,0.02);padding:8px 10px;border-radius:10px;color:var(--muted);display:flex;flex-direction:column;align-items:flex-start}
  .stat strong{color:var(--accent);font-size:16px}
  .controls{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
  button{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);color:var(--accent);padding:8px 12px;border-radius:10px;cursor:pointer}
  button.ghost{background:transparent;color:var(--muted);border:1px dashed rgba(255,255,255,0.03)}
  .small{padding:6px 8px;font-size:13px;border-radius:8px}
  .mutedSmall{color:var(--muted);font-size:12px}
  .center{text-align:center}
  /* Mobile responsiveness */
  @media (max-width:900px){ .layout{flex-direction:column} .right{width:100%} }
  /* Simple on-canvas UI overlays (for small icons) */
  .overlayUI{position:absolute;left:12px;top:12px;display:flex;gap:8px;z-index:5}
  .overlayUI .chip{background:rgba(0,0,0,0.25);padding:6px 8px;border-radius:8px;color:#fff;font-weight:600}
  .footer{margin-top:12px;color:var(--muted);font-size:13px;display:flex;justify-content:space-between}
  /* touch control hint */
  .touchHint{display:none}
  @media (max-width:720px){ .touchHint{display:block;color:var(--muted);font-size:13px;margin-top:8px} }
</style>
</head>
<body>
<div class="app" role="application" aria-label="Arcade Hub with Racing">
  <header>
    <div class="logo">
      <div class="icon">AH</div>
      <div>
        <h1>Arcade Hub — Racing Demo</h1>
        <div class="muted">Top-down responsive car racing mini-game (collect coins, fuel, health, magnet). One file: HTML/CSS/JS.</div>
      </div>
    </div>
    <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
      <div class="muted">Mode</div>
      <select id="device" class="small" title="UI scale for device">
        <option value="auto">Auto</option>
        <option value="desktop">Desktop</option>
        <option value="tablet">Tablet</option>
        <option value="mobile">Mobile</option>
      </select>
    </div>
  </header>

  <div class="layout">
    <div class="left panel">
      <div class="gameWrap" id="gameWrap">
        <canvas id="raceCanvas" width="720" height="900" aria-label="Racing canvas"></canvas>
        <div class="overlayUI">
          <div class="chip" id="levelChip">Level 1</div>
          <div class="chip" id="speedChip">Speed: 1.0x</div>
        </div>
      </div>

      <div class="hud" id="hud">
        <div class="stat">
          <div class="mutedSmall">Score</div>
          <strong id="score">0</strong>
        </div>
        <div class="stat">
          <div class="mutedSmall">Coins</div>
          <strong id="coins">0</strong>
        </div>
        <div class="stat">
          <div class="mutedSmall">Fuel</div>
          <strong id="fuel">100%</strong>
        </div>
        <div class="stat">
          <div class="mutedSmall">Health</div>
          <strong id="health">100%</strong>
        </div>
        <div style="margin-left:auto"></div>
      </div>

      <div class="controls">
        <button id="btnStart">Start</button>
        <button id="btnPause" class="ghost">Pause</button>
        <button id="btnReset" class="ghost">Reset</button>
        <div class="mutedSmall touchHint">Tap left/right or drag to steer on touch</div>
      </div>
    </div>

    <div class="right panel">
      <div>
        <strong>Upgrades & Abilities</strong>
        <div class="mutedSmall" style="margin-top:8px">Collect coins to unlock upgrades (demo credits saved locally).</div>
      </div>

      <div style="margin-top:12px">
        <div class="mutedSmall">Abilities</div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="btnMag" class="small">Use Magnet (3)</button>
          <button id="btnNitro" class="small">Nitro (2)</button>
        </div>
        <div class="mutedSmall" style="margin-top:8px">Magnet collects nearby coins for a short time. Nitro temporarily boosts speed but consumes more fuel.</div>
      </div>

      <div style="margin-top:12px">
        <strong>Level & difficulty</strong>
        <div class="mutedSmall" style="margin-top:8px">Levels become longer and spawn more obstacles & AI cars. Some AI will show turn indicators (left/right) before they change lanes at higher levels.</div>
      </div>

      <div style="margin-top:12px">
        <strong>Controls</strong>
        <ul style="margin:8px 0 0 18px;color:var(--muted);font-size:13px">
          <li>Desktop: Arrow keys or A/D to steer, Space = Nitro</li>
          <li>Mobile: Tap left/right or drag to steer, buttons for abilities</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="footer">
    <div class="muted">Responsive demo — local-only. Built with HTML/CSS/JS in one file.</div>
    <div class="muted">© Arcade Hub</div>
  </div>
</div>

<script>
/*
  Racing Mini-Game (single file)
  Features:
    - Responsive canvas with device mode scaling
    - Top-down lane-based road with obstacles and AI cars
    - Collectables: coins, fuel, health, magnet pickups
    - Abilities: magnet (collect coins), nitro (temporary speed boost)
    - Gradual speed increase with level/time
    - AI cars that sometimes indicate turning left/right before moving lanes at higher levels
    - Touch & desktop controls, HUD, localStorage for coins/score
  How to play:
    - Start -> Use arrow keys/A-D or touch to steer between lanes. Collect coins and pickups.
*/

const canvas = document.getElementById('raceCanvas');
const ctx = canvas.getContext('2d');

let DPR = window.devicePixelRatio || 1;
let CANVAS_W = 720, CANVAS_H = 900;

function resizeCanvasForDevice(mode='auto'){
  DPR = window.devicePixelRatio || 1;
  const wrap = document.getElementById('gameWrap');
  const rect = wrap.getBoundingClientRect();
  const width = Math.max(360, rect.width);
  const height = Math.max(560, window.innerHeight * 0.66);
  canvas.width = Math.floor(width * DPR);
  canvas.height = Math.floor(height * DPR);
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  CANVAS_W = width; CANVAS_H = height;
}
resizeCanvasForDevice();

window.addEventListener('resize', ()=> resizeCanvasForDevice(document.getElementById('device').value));
document.getElementById('device').addEventListener('change', (e)=> resizeCanvasForDevice(e.target.value));

/* Game variables */
const LANE_COUNT = 3; // left, mid, right
let laneX = []; // pixel centers for lanes
let road = {
  laneCount: LANE_COUNT,
  laneWidth: 0,
  topMargin: 0,
  bottomMargin: 0
};

let game = {
  running: false,
  paused: false,
  level:1,
  distance:0,
  speed: 200, // px per second baseline scrolling speed
  speedMultiplier:1,
  spawnTimer: 0,
  spawnInterval: 1.2, // seconds between spawns
  aiDensity: 0.8, // spawn probability
  time: 0,
  coinsCollected: 0,
  score: 0,
  coinsBank: Number(localStorage.getItem('race-coins') || 0),
  abilities: {magnet:3, nitro:2},
  magnetActiveUntil: 0,
  nitroActiveUntil: 0
};

/* Player car model */
let player = {
  lane: 1, // 0-left,1-mid,2-right
  x:0,y:0,
  width: 60, height:110,
  speedX: 600,
  health: 100,
  fuel: 100,
  lightsOn: true
};

/* Entities */
let aiCars = []; // {lane, y, speed, w, h, color, turnIndicator: null|'left'|'right', turnAtY}
let collectibles = []; // coins, fuel, health, magnet pickups

/* Tuning parameters by level */
function tuneForLevel(level){
  const base = 200; // base speed
  game.level = level;
  game.speed = base + (level - 1) * 12; // slightly faster each level
  game.spawnInterval = Math.max(0.6, 1.6 - (level * 0.02));
  game.aiDensity = Math.min(1.6, 0.6 + level * 0.02);
}

/* Initialize lanes */
function computeLanes(){
  road.laneWidth = CANVAS_W * 0.28;
  road.topMargin = Math.floor(CANVAS_H * 0.06);
  road.bottomMargin = Math.floor(CANVAS_H * 0.18);
  const center = CANVAS_W / 2;
  const gap = road.laneWidth + 18;
  laneX = [
    center - gap,
    center,
    center + gap
  ];
  // positioning player
  player.x = laneX[player.lane];
  player.y = CANVAS_H - road.bottomMargin - player.height/2;
}

computeLanes();

/* draw road */
function drawRoad(){
  // background grass
  ctx.fillStyle = '#062027';
  ctx.fillRect(0,0,CANVAS_W,CANVAS_H);
  // road area
  const roadWidth = road.laneWidth * LANE_COUNT + 36 * (LANE_COUNT-1);
  const roadLeft = (CANVAS_W - roadWidth)/2;
  const roadRight = roadLeft + roadWidth;
  // road gradient
  const g = ctx.createLinearGradient(0,0,0,CANVAS_H);
  g.addColorStop(0,'#2b2b2b'); g.addColorStop(1,'#151515');
  ctx.fillStyle = g;
  ctx.fillRect(roadLeft, 0, roadWidth, CANVAS_H);
  // lane separators
  for(let i=1;i<LANE_COUNT;i++){
    const x = (laneX[i-1] + laneX[i]) / 2;
    // dashed center line
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 4;
    ctx.setLineDash([18,18]);
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,CANVAS_H); ctx.stroke();
    ctx.setLineDash([]);
  }
  // road borders
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 2;
  ctx.strokeRect(roadLeft, 0, roadWidth, CANVAS_H);
}

/* draw car (player or AI) - simple stylized car with headlights */
function drawCar(x,y,w,h,color,lights=false, scale=1, flip=false){
  ctx.save();
  ctx.translate(x,y);
  if(flip) ctx.scale(-1,1);
  ctx.beginPath();
  ctx.fillStyle = color;
  roundRect(ctx, -w/2, -h/2, w, h, 10*scale, true, false);
  // windows
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.fillRect(-w*0.2, -h*0.3, w*0.4, h*0.22);
  // wheels
  ctx.fillStyle = '#222';
  ctx.fillRect(-w*0.42, h*0.18, w*0.18, h*0.16);
  ctx.fillRect(w*0.24, h*0.18, w*0.18, h*0.16);
  // headlights
  if(lights){
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,248,200,0.9)';
    ctx.ellipse(-w*0.2, h*0.4, w*0.08, h*0.06, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,248,200,0.9)';
    ctx.ellipse(w*0.2, h*0.4, w*0.08, h*0.06, 0, 0, Math.PI*2); ctx.fill();
    // beam
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,248,200,0.035)';
    ctx.moveTo(-w*0.24, h*0.4);
    ctx.quadraticCurveTo(0, h*1.4, -w*1.3, h*6.0);
    ctx.lineTo(-w*0.9, h*6.0); ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,248,200,0.035)';
    ctx.moveTo(w*0.24, h*0.4);
    ctx.quadraticCurveTo(0, h*1.4, w*1.3, h*6.0);
    ctx.lineTo(w*0.9, h*6.0); ctx.closePath(); ctx.fill();
  }
  ctx.restore();
}

/* rounded rectangle helper */
function roundRect(ctx,x,y,w,h,r,fill,stroke){
  if(typeof r === 'undefined') r=5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* draw HUD overlays on canvas (level, speed chip already in HTML overlay) */
function drawHUDOnCanvas(){
  // small indicators like health bar above player
  const barW = 120;
  const bx = player.x - barW/2, by = player.y - player.height/2 - 26;
  // health
  const healthPct = clamp(player.health/100,0,1);
  ctx.fillStyle = 'rgba(0,0,0,0.5)'; roundRect(ctx, bx-2, by-2, barW+4, 18, 8, true, false);
  ctx.fillStyle = '#444'; roundRect(ctx, bx, by, barW, 12, 6, true, false);
  ctx.fillStyle = lerpColor('#ef4444', '#10b981', healthPct);
  roundRect(ctx, bx, by, barW*healthPct, 12, 6, true, false);
}

/* spawn mechanics for AI and collectibles */
function spawnAI(){
  // spawn in a random lane at top (y negative), speed relative to game.speed
  const lane = Math.floor(Math.random()*LANE_COUNT);
  const x = laneX[lane];
  const w = 56, h = 110;
  const speed = game.speed * (0.6 + Math.random()*0.9); // AI speed relative
  const color = sample(['#ff6b6b','#6bd1ff','#ffd36b','#d86bff']);
  let ai = {lane, x, y: -h - 20, speed, w, h, color, turnIndicator: null, turnAtY: null, willTurn:false};
  // decide if this AI will turn (only at higher levels)
  if(game.level >= 6 && Math.random() < 0.35 + game.level * 0.01){
    ai.willTurn = true;
    // set a random y where it will turn (between 100 and CANVAS_H - 200)
    ai.turnAtY = 60 + Math.random()*(CANVAS_H - 300);
    ai.turnIndicator = Math.random() < 0.5 ? 'left' : 'right';
  }
  aiCars.push(ai);
}

function spawnCollectible(){
  // coin, fuel, health, magnet pickups
  const types = ['coin','coin','coin','fuel','health','magnet'];
  const type = sample(types);
  const lane = Math.floor(Math.random()*LANE_COUNT);
  const pos = {lane, x: laneX[lane], y: -30, type, value: type==='coin'? 1 : (type==='fuel'?20: (type==='health'?20:1))};
  collectibles.push(pos);
}

/* update loop */
let lastTime = performance.now();
function update(ts){
  const dt = Math.min(0.05, (ts - lastTime)/1000);
  lastTime = ts;
  if(game.running && !game.paused){
    // speed multiplier for nitro
    const nowMs = Date.now();
    const nitroActive = game.nitroActiveUntil > nowMs;
    const magnetActive = game.magnetActiveUntil > nowMs;
    const baseSpeed = game.speed * (nitroActive ? 1.6 : 1);
    // move entities downward (scene scrolls up)
    const dy = baseSpeed * dt;
    game.distance += dy;
    game.time += dt;

    // spawn logic
    game.spawnTimer -= dt;
    if(game.spawnTimer <= 0){
      game.spawnTimer = Math.max(0.4, game.spawnInterval * (0.8 + Math.random()*0.6));
      // spawn AI based on density
      if(Math.random() < Math.min(1, 0.2 + game.aiDensity * 0.18)) spawnAI();
      // spawn collectible sometimes
      if(Math.random() < 0.5) spawnCollectible();
    }

    // update AI
    for(let i=aiCars.length-1;i>=0;i--){
      const a = aiCars[i];
      a.y += (a.speed - baseSpeed*0.2) * dt; // relative movement to road
      // if willTurn and near turnAtY, perform lane change
      if(a.willTurn && a.y >= a.turnAtY && a.turnIndicator){
        // compute target lane
        const dir = a.turnIndicator === 'left' ? -1 : 1;
        const targetLane = clamp(a.lane + dir, 0, LANE_COUNT-1);
        // smooth lane transition
        a.lane = targetLane;
        a.x = laneX[a.lane];
        a.turnIndicator = null;
        a.willTurn = false;
      }
      // collision with player?
      if(Math.abs(a.y - player.y) < (a.h/2 + player.height/2) && a.lane === player.lane){
        // collision: reduce health and remove ai
        player.health -= 18;
        if(player.health < 0) player.health = 0;
        aiCars.splice(i,1);
        game.score = Math.max(0, game.score - 20);
      }
      // remove if past screen
      if(a.y > CANVAS_H + 200) aiCars.splice(i,1);
    }

    // collectibles update
    for(let i=collectibles.length-1;i>=0;i--){
      collectibles[i].y += baseSpeed * dt * 0.9;
      const c = collectibles[i];
      // magnet effect: auto-collect if magnet active and within radius
      if(magnetActive){
        const px = player.x, py = player.y;
        const pos = {x: c.x, y: c.y};
        const dist = Math.hypot(px-pos.x, py-pos.y);
        if(dist < 200){
          collectItem(c);
          collectibles.splice(i,1);
          continue;
        }
      }
      // collision: if collectible near player lane and y close
      if(c.lane === player.lane && Math.abs(c.y - player.y) < 60){
        collectItem(c);
        collectibles.splice(i,1);
        continue;
      }
      // drop off screen
      if(c.y > CANVAS_H + 100) collectibles.splice(i,1);
    }

    // fuel drain
    const fuelDrain = dt * (nitroActive ? 8 : 2);
    player.fuel -= fuelDrain;
    if(player.fuel < 0) player.fuel = 0;
    if(player.fuel === 0){
      // slow down player if no fuel and eventually end level if out too long
      game.speedMultiplier = Math.max(0.4, game.speedMultiplier - dt*0.03);
    } else {
      game.speedMultiplier = Math.min(1.2, 1);
    }

    // player controls smoothing: move player x to lane center
    const targetX = laneX[player.lane];
    const dx = targetX - player.x;
    const maxStep = player.speedX * dt;
    if(Math.abs(dx) > maxStep) player.x += Math.sign(dx) * maxStep;
    else player.x = targetX;

    // difficulty increase over time: small speed bump per level distance
    if(game.time > 20){
      game.time = 0;
      game.speed += 6;
      document.getElementById('speedChip').textContent = 'Speed: ' + (game.speed/200).toFixed(2) + 'x';
    }

    // level progression: if distance passes threshold -> next level
    const levelDistance = 1500 + game.level * 600;
    if(game.distance >= levelDistance){
      game.distance = 0;
      nextLevel();
    }

    // player death check
    if(player.health <= 0) {
      gameOver();
    }
  }
}

/* collecting items */
function collectItem(item){
  if(item.type === 'coin'){
    game.coinsCollected += item.value;
    game.coinsBank += item.value;
    game.score += 10 * item.value;
    localStorage.setItem('race-coins', game.coinsBank);
  } else if(item.type === 'fuel'){
    player.fuel = Math.min(100, player.fuel + item.value);
    game.score += 25;
  } else if(item.type === 'health'){
    player.health = Math.min(100, player.health + item.value);
    game.score += 30;
  } else if(item.type === 'magnet'){
    game.abilities.magnet = Math.min(9, game.abilities.magnet + 1);
    game.score += 40;
  }
}

/* next level */
function nextLevel(){
  game.level++;
  tuneForLevel(game.level);
  document.getElementById('levelChip').textContent = 'Level ' + game.level;
  // spawn some starter ai and collectibles to mark new challenge
  for(let i=0;i<Math.min(6, game.level);i++) spawnAI();
  for(let j=0;j<3;j++) spawnCollectible();
}

/* game over */
function gameOver(){
  game.running = false;
  // show simple alert (could be modal)
  setTimeout(()=> alert('Game Over! Score: ' + game.score + '\\nCoins: ' + game.coinsBank), 50);
}

/* rendering */
function render(){
  // clear
  ctx.clearRect(0,0,CANVAS_W,CANVAS_H);
  // draw road
  drawRoad();

  // draw collectibles
  for(const c of collectibles){
    drawCollectible(c);
  }

  // draw AI cars
  for(const a of aiCars){
    drawCar(a.x, a.y, a.w, a.h, a.color, false, 1);
    // draw turn indicator if present
    if(a.turnIndicator){
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '14px Inter';
      ctx.textAlign='center';
      ctx.fillText(a.turnIndicator === 'left' ? '←' : '→', a.x, a.y - a.h/2 - 10);
    }
  }

  // draw player car
  drawCar(player.x, player.y, player.width, player.height, '#3b82f6', player.lightsOn, 1.0);

  // canvas HUD (fuel/health bars near bottom)
  drawStats();

  // request next frame
  requestAnimationFrame(loopRender);
}

function loopRender(){
  render();
}

/* draw collectible icons */
function drawCollectible(c){
  ctx.save();
  const pos = {x: c.x, y: c.y};
  if(c.type === 'coin'){
    ctx.beginPath();
    ctx.fillStyle = '#ffd36b';
    ctx.arc(pos.x, pos.y, 12, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#6b4520'; ctx.font = '12px Inter'; ctx.textAlign='center'; ctx.fillText('¢', pos.x, pos.y+4);
  } else if(c.type === 'fuel'){
    ctx.fillStyle = '#10b981';
    roundRect(ctx,pos.x-12,pos.y-10,24,20,6,true,false);
    ctx.fillStyle = '#072517'; ctx.fillRect(pos.x-6,pos.y-2,12,4);
  } else if(c.type === 'health'){
    ctx.fillStyle = '#ef4444';
    ctx.beginPath(); ctx.moveTo(pos.x,pos.y-8); ctx.arc(pos.x, pos.y-2, 10, -Math.PI, 0); ctx.fill();
  } else if(c.type === 'magnet'){
    ctx.fillStyle = '#c084fc';
    ctx.beginPath(); ctx.arc(pos.x,pos.y,12,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font='12px Inter'; ctx.fillText('M', pos.x, pos.y+4);
  }
  ctx.restore();
}

/* draw bottom stats */
function drawStats(){
  // fuel bar
  const barW = 220, barH=14;
  const x = 16, y = CANVAS_H - 48;
  ctx.fillStyle = 'rgba(0,0,0,0.4)'; roundRect(ctx,x-2,y-4,barW+4,barH+8,8,true,false);
  ctx.fillStyle = '#222'; roundRect(ctx,x,y,barW,barH,6,true,false);
  ctx.fillStyle = '#ffd36b'; roundRect(ctx,x,y,barW * (player.fuel/100), barH,6,true,false);
  ctx.fillStyle = '#fff'; ctx.font='12px Inter'; ctx.fillText('Fuel', x+6, y+barH-2);

  // health
  const hx = x + barW + 12;
  ctx.fillStyle = '#222'; roundRect(ctx,hx,y,150,barH,6,true,false);
  ctx.fillStyle = '#ef4444'; roundRect(ctx,hx,y,150 * (player.health/100),barH,6,true,false);
  ctx.fillStyle = '#fff'; ctx.font='12px Inter'; ctx.fillText('Health', hx+6, y+barH-2);
}

/* utility: sample */
function sample(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

/* lerp color */
function lerpColor(a,b,t){
  // a/b hex strings
  const ca = hexToRgb(a), cb = hexToRgb(b);
  const r = Math.round(ca.r + (cb.r-ca.r)*t);
  const g = Math.round(ca.g + (cb.g-ca.g)*t);
  const bl = Math.round(ca.b + (cb.b-ca.b)*t);
  return `rgb(${r},${g},${bl})`;
}
function hexToRgb(hex){
  const c = hex.replace('#','');
  return {r:parseInt(c.substring(0,2),16), g:parseInt(c.substring(2,4),16), b:parseInt(c.substring(4,6),16)};
}

/* simple helpers */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/* Input handling: keyboard & touch */
document.addEventListener('keydown', (e)=>{
  if(!game.running) return;
  if(e.key === 'ArrowLeft' || e.key === 'a') movePlayerLeft();
  if(e.key === 'ArrowRight' || e.key === 'd') movePlayerRight();
  if(e.key === ' ') activateNitro();
  if(e.key === 'm') activateMagnet();
});

function movePlayerLeft(){ player.lane = clamp(player.lane - 1, 0, LANE_COUNT-1); }
function movePlayerRight(){ player.lane = clamp(player.lane + 1, 0, LANE_COUNT-1); }

/* touch - handle taps and horizontal drags */
let touchStartX = null;
canvas.addEventListener('touchstart', (e)=>{
  if(e.touches.length === 1){
    touchStartX = e.touches[0].clientX;
  }
});
canvas.addEventListener('touchend', (e)=>{
  if(touchStartX === null) return;
  const endX = e.changedTouches[0].clientX;
  const diff = endX - touchStartX;
  if(Math.abs(diff) < 20){
    // tap: decide left or right half
    const rect = canvas.getBoundingClientRect();
    const tapX = endX - rect.left;
    if(tapX < CANVAS_W/2) movePlayerLeft(); else movePlayerRight();
  } else {
    // drag
    if(diff < 0) movePlayerLeft(); else movePlayerRight();
  }
  touchStartX = null;
});

/* abilities */
function activateMagnet(){
  if(game.abilities.magnet <= 0) return;
  game.abilities.magnet--;
  game.magnetActiveUntil = Date.now() + 7000; // 7s
  document.getElementById('btnMag').textContent = 'Use Magnet (' + game.abilities.magnet + ')';
}
function activateNitro(){
  if(game.abilities.nitro <= 0) return;
  game.abilities.nitro--;
  game.nitroActiveUntil = Date.now() + 3500; // 3.5s
  document.getElementById('btnNitro').textContent = 'Nitro (' + game.abilities.nitro + ')';
}

/* Button wiring */
document.getElementById('btnStart').addEventListener('click', ()=> {
  if(!game.running){
    resetGame();
  }
  game.running = true; game.paused = false;
});
document.getElementById('btnPause').addEventListener('click', ()=> { game.paused = !game.paused; document.getElementById('btnPause').textContent = game.paused ? 'Resume' : 'Pause'; });
document.getElementById('btnReset').addEventListener('click', ()=> resetGame());
document.getElementById('btnMag').addEventListener('click', ()=> activateMagnet());
document.getElementById('btnNitro').addEventListener('click', ()=> activateNitro());

/* reset and start */
function resetGame(){
  // clear arrays
  aiCars = []; collectibles = [];
  game.running = true; game.paused = false;
  game.level = 1; game.distance = 0; game.time = 0;
  tuneForLevel(1);
  player.lane = 1; player.health = 100; player.fuel = 100;
  player.x = laneX[player.lane];
  game.score = 0; game.coinsCollected = 0;
  game.spawnTimer = 0;
  document.getElementById('levelChip').textContent = 'Level 1';
  document.getElementById('speedChip').textContent = 'Speed: ' + (game.speed/200).toFixed(2) + 'x';
}

/* game loop */
let lastUpdate = performance.now();
function mainLoop(ts){
  const dt = Math.min(0.05, (ts - lastUpdate)/1000);
  lastUpdate = ts;
  update(ts);
  render();
  requestAnimationFrame(mainLoop);
}
requestAnimationFrame(mainLoop);

/* startup */
function init(){
  computeLanes();
  tuneForLevel(1);
  player.x = laneX[player.lane];
  // initial UI
  document.getElementById('btnMag').textContent = 'Use Magnet (' + game.abilities.magnet + ')';
  document.getElementById('btnNitro').textContent = 'Nitro (' + game.abilities.nitro + ')';
  document.getElementById('score').textContent = game.score;
  document.getElementById('coins').textContent = game.coinsBank;
  document.getElementById('fuel').textContent = Math.floor(player.fuel) + '%';
  document.getElementById('health').textContent = Math.floor(player.health) + '%';
}
init();

/* render update interval for HUD text elements */
setInterval(()=> {
  document.getElementById('score').textContent = Math.floor(game.score);
  document.getElementById('coins').textContent = game.coinsBank;
  document.getElementById('fuel').textContent = Math.floor(player.fuel) + '%';
  document.getElementById('health').textContent = Math.floor(player.health) + '%';
}, 200);

/* small polish: spawn some starting collectibles */
for(let i=0;i<3;i++) spawnCollectible();
for(let i=0;i<2;i++) spawnAI();

/* End of file */
</script>
</body>
</html>
