<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bubble Royale — Responsive & Enhanced (Day/Night, Abilities, 100+ Levels)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg-dark-0:#071322; --bg-dark-1:#0b2030;
    --bg-light-0:#f6f8fa; --bg-light-1:#e9eef6;
    --muted-dark:#9fb0c7; --muted-light:#475569;
    --accent:#ffb86b;
    --glass: rgba(255,255,255,0.03);
    --panel-dark: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    --panel-light: linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0.01));
    --success:#10b981; --danger:#ef4444;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;-webkit-font-smoothing:antialiased}
  body.theme-dark{
    background: radial-gradient(800px 400px at 10% 10%, rgba(255,184,107,0.03), transparent), linear-gradient(180deg,var(--bg-dark-0),var(--bg-dark-1));
    color:#e6eef8;
  }
  body.theme-light{
    background: linear-gradient(180deg,var(--bg-light-0),var(--bg-light-1));
    color:#0b1220;
  }
  .app{max-width:1200px;margin:18px auto;padding:16px;border-radius:14px;background:var(--panel-dark);box-shadow:0 18px 50px rgba(0,0,0,0.45);border:1px solid rgba(255,255,255,0.03)}
  body.theme-light .app{background:var(--panel-light);box-shadow:0 10px 28px rgba(2,6,23,0.06);border:1px solid rgba(0,0,0,0.04)}
  header{display:flex;gap:12px;align-items:center;margin-bottom:12px}
  .logo{display:flex;align-items:center;gap:10px}
  .logo .icon{width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,#ffb86b,#ff7b7b);display:flex;align-items:center;justify-content:center;font-weight:700;color:#081022}
  h1{margin:0;font-size:18px}
  .muted{color:var(--muted-dark);font-size:13px}
  body.theme-light .muted{color:var(--muted-light)}
  .layout{display:flex;gap:14px}
  .left{flex:1;min-width:320px}
  .right{width:340px}
  .panel{padding:12px;border-radius:12px;background:transparent;border:1px solid rgba(255,255,255,0.02)}
  .canvasWrap{position:relative;border-radius:12px;overflow:hidden;background:linear-gradient(180deg,#05202b,#02121a);display:flex;align-items:center;justify-content:center;padding:10px}
  body.theme-light .canvasWrap{background:linear-gradient(180deg,#f3f7fb,#eaf3ff)}
  canvas{display:block;width:100%;height:auto;border-radius:8px;background:transparent}
  .hud{display:flex;align-items:center;gap:10px;margin-top:10px;flex-wrap:wrap}
  .badge{background:rgba(255,255,255,0.03);padding:8px 10px;border-radius:10px;color:var(--muted-dark);font-weight:600}
  body.theme-light .badge{background:rgba(0,0,0,0.03);color:var(--muted-light)}
  .big{font-size:18px;color:var(--accent);font-weight:700}
  .controls{display:flex;gap:8px;align-items:center;margin-top:10px;flex-wrap:wrap}
  .ability{display:flex;flex-direction:column;align-items:center;gap:6px}
  .ability button{width:120px}
  button{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);color:var(--accent);padding:8px 12px;border-radius:10px;cursor:pointer}
  button.ghost{background:transparent;color:var(--muted-dark);border:1px dashed rgba(255,255,255,0.03)}
  .levelProgress{height:10px;background:rgba(255,255,255,0.03);border-radius:6px;overflow:hidden}
  .levelBar{height:100%;background:linear-gradient(90deg,#ffb86b,#ff7b7b);width:0%}
  .controls .hint{font-size:12px;color:var(--muted-dark)}
  .center{text-align:center}
  .instructions{font-size:13px;color:var(--muted-dark);margin-top:8px}
  .deviceMode{display:flex;gap:6px}
  .small{padding:6px 8px;font-size:13px;border-radius:8px}
  .nextQueue{display:flex;gap:6px;align-items:center}
  .nextBall{width:46px;height:46px;border-radius:10px;display:flex;align-items:center;justify-content:center;border:1px solid rgba(255,255,255,0.04)}
  .dayToggle{cursor:pointer;padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent}
  @media (max-width:980px){ .layout{flex-direction:column} .right{width:100%} .nextBall{width:38px;height:38px} }
</style>
</head>
<body class="theme-dark">
<div class="app" role="application" aria-label="Bubble Shooter - Enhanced">
  <header>
    <div class="logo">
      <div class="icon">BR</div>
      <div>
        <h1>Bubble Royale — Enhanced</h1>
        <div class="muted">Responsive canvas, clearer aim, abilities (Wild / Fire / Ice), day/night & device modes</div>
      </div>
    </div>

    <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
      <div class="muted deviceMode">
        <label class="muted">Mode:</label>
        <select id="deviceMode" class="small" title="Change UI scale for device">
          <option value="auto">Auto</option>
          <option value="desktop">Desktop</option>
          <option value="tablet">Tablet</option>
          <option value="mobile">Mobile</option>
        </select>
      </div>

      <div class="dayToggle" id="dayToggle" title="Toggle Day / Night" aria-pressed="false">🌙</div>
      <div class="badge">Level: <span id="uiLevel" class="big">1</span></div>
      <div class="badge">Score: <span id="uiScore" class="big">0</span></div>
    </div>
  </header>

  <div class="layout">
    <div class="left">
      <div class="panel canvasWrap" id="gamePanel" style="padding:8px">
        <canvas id="gameCanvas" width="720" height="900" aria-label="Game canvas"></canvas>
        <div id="overlay" style="position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none"></div>
      </div>

      <div class="hud">
        <div class="badge">Next:</div>
        <div class="nextQueue" id="nextQueue"></div>
        <div class="badge">Shots: <span id="uiShots">0</span></div>
        <div style="margin-left:auto" class="muted">Aim: drag/touch or move mouse. Click / Tap to shoot. Keys: Space = shoot, 1 = Wild, 2 = Fire, 3 = Ice</div>
      </div>

      <div class="controls">
        <div class="ability">
          <button id="btnWild">1: Wild <span id="wildCount">x1</span></button>
          <div class="muted">Wildcard matches any color</div>
        </div>
        <div class="ability">
          <button id="btnFire">2: Fire <span id="fireCount">x1</span></button>
          <div class="muted">Area destroy on impact</div>
        </div>
        <div class="ability">
          <button id="btnIce">3: Ice <span id="iceCount">x1</span></button>
          <div class="muted">Convert small area to shooter color</div>
        </div>

        <div style="margin-left:auto;display:flex;gap:8px">
          <button id="btnPrev" class="ghost small">Prev</button>
          <button id="btnNext" class="ghost small">Next</button>
          <button id="btnReset" class="ghost small">Reset Progress</button>
        </div>
      </div>

      <div style="margin-top:12px" class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Level Progress</strong>
          <div id="uiRemaining" class="muted">Bubbles left: 0</div>
        </div>
        <div style="margin-top:10px" class="levelProgress" aria-hidden="true"><div id="levelBar" class="levelBar"></div></div>
        <div class="instructions">This build is responsive across Desktop, Tablet and Mobile. Use abilities and aim carefully. New rows will be added periodically (configurable) and after selected events to extend gameplay.</div>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Game Info</strong><div class="muted">Saved locally</div>
        </div>

        <div style="margin-top:12px">
          <div class="muted">Controls</div>
          <ul style="margin:8px 0 0 18px;color:var(--muted-dark)">
            <li>Mouse/touch to aim & click/tap to shoot</li>
            <li>Space = quick shoot</li>
            <li>1 = Wild, 2 = Fire, 3 = Ice</li>
            <li>Every X shots adds a new row (configurable). After clearing level, extra rows may be added to next levels for challenge.</li>
          </ul>
        </div>

        <hr style="margin:12px 0;border:none;height:1px;background:rgba(255,255,255,0.03)">

        <div>
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Settings</strong><div class="muted">Tweaks for play</div></div>
            <div>
              <label class="muted">Add row every</label>
              <select id="addRowEvery" class="small" title="Shots until a new row is added">
                <option value="0">Off</option>
                <option value="6">6 shots</option>
                <option value="8" selected>8 shots</option>
                <option value="12">12 shots</option>
              </select>
            </div>
          </div>
        </div>

        <hr style="margin:12px 0;border:none;height:1px;background:rgba(255,255,255,0.03)">

        <div>
          <strong>Levels</strong>
          <div style="margin-top:8px" class="muted">Procedural +120 levels. Next level adds more rows/colors to increase difficulty.</div>
        </div>
      </div>

      <div style="height:12px"></div>

      <div class="panel">
        <strong>Tips</strong>
        <ol style="margin:8px 0 0 18px;color:var(--muted-dark)">
          <li>Bounce shots off walls to reach pockets.</li>
          <li>Use Wild for awkward single bubbles; Fire to break islands; Ice to line up matches.</li>
        </ol>
      </div>
    </div>
  </div>

  <div style="height:10px"></div>
  <div style="text-align:center;color:var(--muted-dark)">Built as a single-file web app — open, local-only</div>
</div>

<script>
/*
  Enhanced Bubble Royale
  - Responsive canvas with device modes
  - Clearer aim indicator (arrow + long line)
  - Next queue of 3 preview balls with color labels
  - Abilities: Wild, Fire, Ice
  - Add-top-row mechanic every N shots (configurable) and extra rows applied between levels
  - Day/Night toggle
  - Improved touch & desktop responsiveness
  - Local progress saved to localStorage
*/

/* -----------------------
   Config & Utilities
   ----------------------- */
const SAVE_KEY = 'bubble-royale-save-v2';
const TOTAL_LEVELS = 120;
const COLOR_PALETTE = ['#ff6b6b','#ffd36b','#6bf5a3','#6bd1ff','#d86bff','#ffa09b']; // clear distinct colors
const NAME_PALETTE = ['Red','Yellow','Green','Cyan','Purple','Peach'];
const DEVICE_MODES = {auto:'auto', desktop:'desktop', tablet:'tablet', mobile:'mobile'};
let deviceMode = 'auto';
let isDay = false;

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rand(n){ return Math.floor(Math.random()*n); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=rand(i+1); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function now(){ return Date.now(); }

/* -----------------------
   Canvas & scaling
   ----------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const nextQueueEl = document.getElementById('nextQueue');

let DPR = window.devicePixelRatio || 1;
let CANVAS_W = 720, CANVAS_H = 900;
let CELL_RADIUS_BASE = 20; // base radius used for calculations; scaled by device mode
let TOP_PADDING_RATIO = 0.08; // top padding fraction of canvas height

function applyDeviceMode(mode){
  deviceMode = mode;
  if(mode === 'desktop'){ CELL_RADIUS = 24; }
  else if(mode === 'tablet'){ CELL_RADIUS = 20; }
  else if(mode === 'mobile'){ CELL_RADIUS = 16; }
  else { // auto: choose based on container width
    const cw = canvas.getBoundingClientRect().width;
    if(cw > 720) CELL_RADIUS = 24;
    else if(cw > 480) CELL_RADIUS = 20;
    else CELL_RADIUS = 16;
  }
  resizeCanvas();
}
let CELL_RADIUS = CELL_RADIUS_BASE;

/* resize canvas to container, set DPR */
function resizeCanvas(){
  DPR = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  // Ensure canvas has correct aspect ratio and fits container
  const width = Math.max(420, rect.width);
  const height = Math.max(640, window.innerHeight * 0.68);
  canvas.width = Math.floor(width * DPR);
  canvas.height = Math.floor(height * DPR);
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  CANVAS_W = width; CANVAS_H = height;
  // adjust cell radius if in auto
  if(deviceMode === 'auto'){
    if(CANVAS_W > 900) CELL_RADIUS = 26;
    else if(CANVAS_W > 720) CELL_RADIUS = 22;
    else if(CANVAS_W > 520) CELL_RADIUS = 18;
    else CELL_RADIUS = 14;
  }
}
window.addEventListener('resize', ()=>{ applyDeviceMode(deviceMode); });

/* -----------------------
   Game State
   ----------------------- */
let state = {
  level:1,
  unlocked:1,
  score:0,
  abilities: {wild:1, fire:1, ice:1},
  addRowEvery: Number(document.getElementById('addRowEvery').value) || 8,
  shooter: {angle:-Math.PI/2, ball:null, queue:[], shots:0},
  anim: {projectiles:[]},
  running:true
};

let currentLevel = null; // {grid, rows, cols, colorCount}
let levelInitialCount = 0;

/* -----------------------
   Persistence
   ----------------------- */
function saveProgress(){
  try{
    const s = {level: state.level, unlocked: state.unlocked, score: state.score, abilities: state.abilities};
    localStorage.setItem(SAVE_KEY, JSON.stringify(s));
  }catch(e){}
}
function loadProgress(){
  try{
    const s = JSON.parse(localStorage.getItem(SAVE_KEY) || '{}');
    if(s){
      state.level = s.level || 1;
      state.unlocked = s.unlocked || 1;
      state.score = s.score || 0;
      state.abilities = s.abilities || state.abilities;
    }
  }catch(e){}
}

/* -----------------------
   Level Generation (improved)
   ----------------------- */
function generateLevel(index, extraRows=0){
  // scale difficulty: colorCount increases slowly, rows increase
  const diff = clamp(index,1,TOTAL_LEVELS);
  const colorCount = clamp(3 + Math.floor((diff-1)/20), 3, COLOR_PALETTE.length);
  const rows = clamp(5 + Math.floor((diff-1)/6) + extraRows, 4, 14); // up to 14 rows
  const cols = 12;
  const grid = [];
  const baseFill = 0.66 - Math.min(0.22, diff / TOTAL_LEVELS * 0.3);
  for(let r=0;r<rows;r++){
    const row = new Array(cols).fill(null);
    for(let c=0;c<cols;c++){
      const fillProb = baseFill + (1 - r/rows) * 0.18; // top rows more dense
      if(Math.random() < fillProb){
        const color = rand(colorCount);
        row[c] = {color, special: null};
      }
    }
    grid.push(row);
  }
  // ensure playability: create some pocket clusters
  for(let i=0;i<Math.floor(rows*cols/40);i++){
    const pr = rand(rows-1); const pc = rand(cols-2)+1;
    const baseColor = rand(colorCount);
    grid[pr][pc] = {color:baseColor, special:null};
    if(pc>0) grid[pr][pc-1] = {color:baseColor, special:null};
    if(pc<cols-1) grid[pr][pc+1] = {color:baseColor, special:null};
  }
  // obstacles for higher levels
  if(index > 30){
    const stones = Math.floor(index/24);
    for(let s=0;s<stones;s++){
      const r = rand(rows-1); const c = rand(cols);
      if(grid[r][c]) grid[r][c].special = 'stone';
    }
  }
  return {grid, rows, cols, colorCount};
}

/* -----------------------
   Grid math (staggered rows)
   ----------------------- */
function getCellPosition(r,c){
  // grid widths adapt to canvas width
  const cols = currentLevel.cols;
  const topPad = Math.max(40, CANVAS_H * TOP_PADDING_RATIO);
  const fullWidth = CANVAS_W - 40;
  const cellSpacingX = fullWidth / cols;
  const cellRadius = Math.min(CELL_RADIUS, Math.floor(cellSpacingX * 0.45));
  const xBase = 20 + c * cellSpacingX + cellSpacingX/2;
  const x = xBase + (r%2 === 1 ? cellSpacingX/2 : 0);
  const y = topPad + r * (cellRadius * 1.73);
  return {x,y,radius:cellRadius};
}

/* -----------------------
   Rendering
   ----------------------- */
function clearCanvas(){
  ctx.clearRect(0,0,CANVAS_W, CANVAS_H);
}
function draw(){
  clearCanvas();
  // Background
  if(document.body.classList.contains('theme-dark')){
    const g = ctx.createLinearGradient(0,0,0,CANVAS_H);
    g.addColorStop(0,'#06222a'); g.addColorStop(1,'#02121a');
    ctx.fillStyle = g; ctx.fillRect(0,0,CANVAS_W,CANVAS_H);
  } else {
    const g = ctx.createLinearGradient(0,0,0,CANVAS_H);
    g.addColorStop(0,'#f8fafc'); g.addColorStop(1,'#eef6fb');
    ctx.fillStyle = g; ctx.fillRect(0,0,CANVAS_W,CANVAS_H);
  }

  if(!currentLevel) return;
  // draw bubbles
  for(let r=0;r<currentLevel.rows;r++){
    for(let c=0;c<currentLevel.cols;c++){
      const cell = currentLevel.grid[r][c];
      if(!cell) continue;
      const pos = getCellPosition(r,c);
      drawBubble(pos.x, pos.y, pos.radius, cell);
    }
  }

  // draw projectiles
  for(const p of state.anim.projectiles){
    drawMovingBall(p);
  }

  // draw shooter base
  const sx = CANVAS_W/2, sy = CANVAS_H - 60;
  drawShooter(sx,sy);

  // draw aim indicator (if ready to shoot and no projectile active)
  if(state.shooter.ball && state.anim.projectiles.length === 0){
    drawAim(sx,sy,state.shooter.angle);
  }

  // update UI
  updateNextQueueUI();
  document.getElementById('uiRemaining').textContent = 'Bubbles left: ' + countRemaining();
  document.getElementById('levelBar').style.width = `${Math.floor(100*(1 - countRemaining()/(levelInitialCount||1)))}%`;
  document.getElementById('uiScore').textContent = state.score;
  document.getElementById('uiLevel').textContent = state.level;
  document.getElementById('uiShots').textContent = state.shooter.shots;
}

/* draw functions */
function drawBubble(x,y,r,cell){
  // gradient
  const color = COLOR_PALETTE[cell.color % COLOR_PALETTE.length];
  const g = ctx.createRadialGradient(x - r*0.3, y - r*0.4, r*0.15, x, y, r*1.2);
  if(cell.special === 'wild'){ g.addColorStop(0,'#fff'); g.addColorStop(0.4,'#ffd36b'); g.addColorStop(1,color); }
  else { g.addColorStop(0, shade(color,0.25)); g.addColorStop(1, color); }
  ctx.beginPath(); ctx.fillStyle = g; ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  // border
  ctx.beginPath(); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.arc(x,y,r-1,0,Math.PI*2); ctx.stroke();
  // special markers
  if(cell.special === 'stone'){
    ctx.fillStyle = 'rgba(0,0,0,0.28)'; ctx.beginPath(); ctx.arc(x,y,r*0.62,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = document.body.classList.contains('theme-dark') ? '#cbd5e1' : '#1f2937'; ctx.font = `${r*0.7}px Inter`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('■', x, y);
  }
}

function drawMovingBall(p){
  const g = ctx.createRadialGradient(p.x - p.radius*0.3, p.y - p.radius*0.4, p.radius*0.15, p.x, p.y, p.radius*1.1);
  const color = (p.special === 'wild') ? '#fff' : COLOR_PALETTE[p.color % COLOR_PALETTE.length];
  if(p.special === 'wild'){ g.addColorStop(0,'#fff'); g.addColorStop(0.4,'#ffd36b'); g.addColorStop(1,'#ff6b6b'); }
  else g.addColorStop(0, shade(color,0.3)), g.addColorStop(1,color);
  ctx.beginPath(); ctx.fillStyle = g; ctx.arc(p.x,p.y,p.radius,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.arc(p.x,p.y,p.radius-1,0,Math.PI*2); ctx.stroke();
}

function drawShooter(x,y){
  // base circle
  ctx.beginPath(); ctx.fillStyle = document.body.classList.contains('theme-dark') ? '#081426' : '#ffffff'; ctx.globalAlpha = 0.06; ctx.arc(x,y,42,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
  ctx.beginPath(); ctx.fillStyle = document.body.classList.contains('theme-dark') ? '#08303a' : '#f2f7fb'; ctx.arc(x,y,36,0,Math.PI*2); ctx.fill();
  // cannon body
  ctx.save(); ctx.translate(x,y); ctx.rotate(state.shooter.angle + Math.PI/2);
  ctx.fillStyle = '#0ea5a5'; ctx.fillRect(-10,-56,20,44);
  ctx.restore();
  // draw current ball at tip
  const tipX = x + Math.cos(state.shooter.angle)*48;
  const tipY = y + Math.sin(state.shooter.angle)*48;
  const ball = state.shooter.ball || {color: rand(currentLevel.colorCount), special:null};
  drawBubble(tipX, tipY, CELL_RADIUS*0.9, ball);
}

function drawAim(sx,sy,angle){
  // long dashed line and arrow
  ctx.beginPath();
  ctx.setLineDash([6,8]);
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 2;
  ctx.moveTo(sx,sy);
  const len = Math.min(1000, Math.max(300, CANVAS_W * 0.8));
  const ex = sx + Math.cos(angle) * len;
  const ey = sy + Math.sin(angle) * len;
  ctx.lineTo(ex,ey); ctx.stroke();
  ctx.setLineDash([]);
  // arrow head
  const ax = sx + Math.cos(angle) * (len - 18);
  const ay = sy + Math.sin(angle) * (len - 18);
  ctx.save();
  ctx.translate(ax, ay); ctx.rotate(angle + Math.PI/2);
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-8, -18); ctx.lineTo(8,-18); ctx.closePath(); ctx.fill();
  ctx.restore();
}

/* show next queue in UI */
function updateNextQueueUI(){
  nextQueueEl.innerHTML = '';
  for(let i=0;i<3;i++){
    const q = state.shooter.queue[i] || state.shooter.ball;
    const el = document.createElement('div'); el.className = 'nextBall';
    el.style.background = 'transparent';
    const r = document.createElement('div');
    r.style.width='36px'; r.style.height='36px'; r.style.borderRadius='8px';
    r.style.display='flex'; r.style.alignItems='center'; r.style.justifyContent='center';
    r.style.fontWeight='700'; r.style.boxShadow = 'inset 0 -6px 20px rgba(0,0,0,0.12)';
    if(!q) { r.textContent='—'; } else {
      const color = q.special === 'wild' ? '#ffd36b' : COLOR_PALETTE[q.color % COLOR_PALETTE.length];
      r.style.background = color;
      r.textContent = q.special === 'fire' ? '🔥' : (q.special === 'wild' ? '★' : '');
    }
    el.appendChild(r);
    const label = document.createElement('div'); label.style.fontSize='11px'; label.style.color='var(--muted-dark)'; label.style.marginLeft='6px';
    label.textContent = q && q.special ? q.special.toUpperCase() : (q ? NAME_PALETTE[q.color] : '');
    el.style.display='flex'; el.style.alignItems='center';
    el.style.gap='8px'; el.style.padding='4px';
    el.appendChild(label);
    nextQueueEl.appendChild(el);
  }
  // update ability counts
  document.getElementById('wildCount').textContent = 'x' + state.abilities.wild;
  document.getElementById('fireCount').textContent = 'x' + state.abilities.fire;
  document.getElementById('iceCount').textContent = 'x' + state.abilities.ice;
}

/* -----------------------
   Game mechanics
   ----------------------- */
function loadLevel(index, extraRows=0){
  index = clamp(index,1,TOTAL_LEVELS);
  state.level = index;
  currentLevel = generateLevel(index, extraRows);
  levelInitialCount = countGrid(currentLevel.grid);
  // init shooter queue
  state.shooter.queue = [];
  for(let i=0;i<4;i++) state.shooter.queue.push(randomBall(currentLevel.colorCount));
  state.shooter.ball = state.shooter.queue.shift();
  state.anim.projectiles = [];
  state.shooter.shots = 0;
  saveProgress();
  draw();
}

function randomBall(colorCount){
  return {color: rand(colorCount), special: null};
}

function countGrid(grid){
  let c=0; for(const r of grid) for(const cell of r) if(cell) c++; return c;
}
function countRemaining(){ return currentLevel ? countGrid(currentLevel.grid) : 0; }

/* shooting */
function shoot(angle, specialOverride=null){
  if(!currentLevel) return;
  if(state.anim.projectiles.length > 0) return; // one projectile at time
  const cw = CANVAS_W, ch = CANVAS_H;
  const sx = cw/2, sy = ch - 60;
  const ball = Object.assign({}, state.shooter.ball || randomBall(currentLevel.colorCount));
  if(specialOverride) ball.special = specialOverride;
  // create projectile with speed scaled by canvas size
  const baseSpeed = clamp(CANVAS_W/1.2, 600, 1200);
  const p = {
    x: sx, y: sy,
    vx: Math.cos(angle) * baseSpeed,
    vy: Math.sin(angle) * baseSpeed,
    radius: Math.max(10, CELL_RADIUS * 0.9),
    color: ball.color,
    special: ball.special,
    createdAt: now()
  };
  state.anim.projectiles.push(p);
  // advance queue
  state.shooter.ball = state.shooter.queue.shift() || randomBall(currentLevel.colorCount);
  state.shooter.queue.push(randomBall(currentLevel.colorCount));
  state.shooter.shots++;
  // after shot, maybe add row every N shots
  if(Number(document.getElementById('addRowEvery').value) > 0){
    if(state.shooter.shots % Number(document.getElementById('addRowEvery').value) === 0){
      addRowToTop();
      toast('New row added!');
    }
  }
}

/* move projectiles and handle collisions */
let lastFrame = performance.now();
function gameLoop(ts){
  const dt = Math.min(0.04, (ts - lastFrame)/1000); lastFrame = ts;
  updateProjectiles(dt);
  draw();
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

function updateProjectiles(dt){
  if(!currentLevel) return;
  const topPad = Math.max(40, CANVAS_H * TOP_PADDING_RATIO);
  for(let i = state.anim.projectiles.length - 1; i >= 0; i--){
    const p = state.anim.projectiles[i];
    p.x += p.vx * dt; p.y += p.vy * dt;
    // bounce walls
    if(p.x - p.radius <= 10){ p.x = 10 + p.radius; p.vx *= -1; }
    if(p.x + p.radius >= CANVAS_W - 10){ p.x = CANVAS_W - 10 - p.radius; p.vx *= -1; }
    // top boundary
    if(p.y - p.radius <= topPad){
      // snap to topmost row
      const row = 0;
      const col = findNearestColumn(p.x, row);
      placeProjectileAt(row, col, p);
      state.anim.projectiles.splice(i,1);
      continue;
    }
    // collision with existing bubble
    let collided = false;
    outer:
    for(let r=0;r<currentLevel.rows;r++){
      for(let c=0;c<currentLevel.cols;c++){
        const cell = currentLevel.grid[r][c];
        if(!cell) continue;
        const pos = getCellPosition(r,c);
        const dx = p.x - pos.x, dy = p.y - pos.y;
        const dist = Math.hypot(dx,dy);
        if(dist <= p.radius + pos.radius - 2){
          const placement = findPlacementAround(r,c,p.x,p.y);
          if(placement) placeProjectileAt(placement.r, placement.c, p);
          else placeProjectileAt(r,c,p);
          state.anim.projectiles.splice(i,1);
          collided = true;
          break outer;
        }
      }
    }
    // remove if off bottom (shouldn't)
    if(p.y - p.radius > CANVAS_H + 200){ state.anim.projectiles.splice(i,1); }
  }
}

/* placement helper */
function findNearestColumn(x, row){
  let best = 0; let bestd = 1e9;
  for(let c=0;c<currentLevel.cols;c++){
    const pos = getCellPosition(row,c);
    const d = Math.abs(pos.x - x);
    if(d < bestd){ bestd = d; best = c; }
  }
  return best;
}
function findPlacementAround(r,c,x,y){
  const neighbors = getNeighbors(r,c);
  const candidates = [];
  for(const n of neighbors){
    if(n.r < 0 || n.r >= currentLevel.rows || n.c < 0 || n.c >= currentLevel.cols) continue;
    if(!currentLevel.grid[n.r][n.c]) candidates.push(n);
  }
  if(candidates.length === 0) return null;
  candidates.sort((a,b)=>{
    const pa = getCellPosition(a.r,a.c), pb = getCellPosition(b.r,b.c); return Math.hypot(pa.x-x,pa.y-y) - Math.hypot(pb.x-x,pb.y-y);
  });
  return candidates[0];
}

function placeProjectileAt(r,c, p){
  // if occupied, try neighbors
  if(currentLevel.grid[r][c]){
    const nb = findPlacementAround(r,c,p.x,p.y);
    if(nb) { r = nb.r; c = nb.c; }
    else { /* fail placement */ return; }
  }
  // If target is stone and not fire, convert to blocked placement: try neighbors instead
  if(currentLevel.grid[r] && currentLevel.grid[r][c] && currentLevel.grid[r][c].special === 'stone' && p.special !== 'fire'){
    const nb = findPlacementAround(r,c,p.x,p.y);
    if(nb){ r=nb.r; c=nb.c; } else return;
  }

  // do the placement
  currentLevel.grid[r][c] = {color: p.color, special: p.special === 'wild' ? 'wild' : (p.special === 'fire' ? null : null)};
  // if fire: destroy area
  if(p.special === 'fire') { destroyRadius(r,c,2); state.score += 12; }
  else if(p.special === 'ice'){ // ice converts small area to this color
    convertAreaToColor(r,c,p.color,1); state.score += 6;
  } else {
    // normal: gather cluster
    const cluster = gatherCluster(r,c);
    if(cluster.length >= 3){
      for(const cell of cluster) currentLevel.grid[cell.r][cell.c] = null;
      state.score += cluster.length * 10;
      // after clearing, remove floating
      removeFloating();
    }
  }

  // check win
  if(countRemaining() === 0){
    onLevelComplete();
  }
}

/* -----------------------
   Cluster & float logic
   ----------------------- */
function gatherCluster(sr,sc){
  const grid = currentLevel.grid;
  const start = grid[sr][sc];
  if(!start) return [];
  const visited = {};
  const out = [];
  const stack = [{r:sr,c:sc}];
  while(stack.length){
    const cur = stack.pop();
    const key = cur.r + ',' + cur.c;
    if(visited[key]) continue;
    visited[key] = true;
    const cell = grid[cur.r] && grid[cur.r][cur.c];
    if(!cell) continue;
    const matches = (cell.special === 'wild') || (start.special === 'wild') || (cell.color === start.color);
    if(matches){
      out.push({r:cur.r,c:cur.c});
      const neigh = getNeighbors(cur.r, cur.c);
      for(const n of neigh) if(!visited[n.r+','+n.c]) stack.push(n);
    }
  }
  return out;
}

function getNeighbors(r,c){
  // 6-neighbor offset using odd-row staggering
  const neighbors = [];
  const isOdd = r % 2 === 1;
  // left/right
  neighbors.push({r,c:c-1}); neighbors.push({r,c:c+1});
  // up/down
  neighbors.push({r:r-1,c});
  neighbors.push({r:r+1,c});
  // diagonal depends on row parity
  neighbors.push({r:r-1, c: isOdd ? c+1 : c-1});
  neighbors.push({r:r+1, c: isOdd ? c+1 : c-1});
  return neighbors;
}

function removeFloating(){
  const grid = currentLevel.grid; const rows = currentLevel.rows, cols = currentLevel.cols;
  const visited = {}; const connected = {};
  const stack = [];
  for(let c=0;c<cols;c++) if(grid[0][c]) stack.push({r:0,c});
  while(stack.length){
    const cur = stack.pop(); const k = cur.r+','+cur.c; if(visited[k]) continue; visited[k]=true; connected[k]=true;
    const neigh = getNeighbors(cur.r,cur.c);
    for(const n of neigh) if(n.r>=0 && n.r<rows && n.c>=0 && n.c<cols && grid[n.r][n.c] && !visited[n.r+','+n.c]) stack.push(n);
  }
  let removed=0;
  for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(grid[r][c]){ if(!connected[r+','+c]){ grid[r][c]=null; removed++; } }
  if(removed>0) state.score += removed * 5;
}

/* destroy radius (for fire) */
function destroyRadius(cr,cc,radius){
  for(let r=cr-radius;r<=cr+radius;r++){
    for(let c=cc-radius;c<=cc+radius;c++){
      if(r>=0 && r<currentLevel.rows && c>=0 && c<currentLevel.cols){
        currentLevel.grid[r][c] = null;
      }
    }
  }
  removeFloating();
}

/* ice convert area to color */
function convertAreaToColor(cr,cc, color, radius){
  for(let r=cr-radius;r<=cr+radius;r++){
    for(let c=cc-radius;c<=cc+radius;c++){
      if(r>=0 && r<currentLevel.rows && c>=0 && c<currentLevel.cols && currentLevel.grid[r][c]){
        currentLevel.grid[r][c].color = color;
      }
    }
  }
}

/* -----------------------
   Row addition mechanic
   ----------------------- */
function addRowToTop(){
  // pushes new row at top, drops bottom row if exceeding max rows visible
  const cols = currentLevel.cols;
  const newRow = new Array(cols).fill(null);
  const colorCount = currentLevel.colorCount;
  for(let c=0;c<cols;c++){
    if(Math.random() < 0.72) newRow[c] = {color: rand(colorCount), special: null};
  }
  // insert at top
  currentLevel.grid.unshift(newRow);
  currentLevel.rows = currentLevel.grid.length;
  // ensure we don't exceed max allowed rows space; if too many rows push bottom off and cause game over if bubble crosses threshold
  // we'll cap display to 16 rows; if overflow, drop last row
  if(currentLevel.rows > 16){
    currentLevel.grid.pop();
    currentLevel.rows = currentLevel.grid.length;
  }
  // if any bubble reaches too low (near shooter) -> game over
  const bottomY = getCellPosition(currentLevel.rows - 1, 0).y;
  const sy = CANVAS_H - 60;
  if(bottomY + CELL_RADIUS * 1.1 >= sy - 18){
    // game over for this level: reset level with penalty (add one extra row next)
    toast('Bubbles reached bottom! Level reset with penalty.');
    // reload level with an extra row to increase challenge
    loadLevel(state.level, 1);
  }
}

/* -----------------------
   Level completion
   ----------------------- */
function onLevelComplete(){
  // award points
  const reward = 150 + Math.floor(currentLevel.rows * 10);
  state.score += reward;
  state.unlocked = Math.max(state.unlocked, state.level + 1);
  saveProgress();
  toast(`Cleared Level ${state.level}! +${reward} pts`);
  // Give small abilities rewards occasionally
  if(state.level % 5 === 0){ state.abilities.fire++; toast('You earned a Fireball!'); }
  if(state.level % 7 === 0){ state.abilities.wild++; toast('You earned a Wild Ball!'); }
  // For next level, add a couple extra rows to increase difficulty
  setTimeout(()=> loadLevel(state.level + 1, 1), 900);
}

/* -----------------------
   Helpers & UI
   ----------------------- */
function toast(msg){
  overlay.innerHTML = `<div style="position:absolute;left:50%;top:12px;transform:translateX(-50%);background:linear-gradient(90deg,#ffb86b,#ff7b7b);color:#081022;padding:8px 14px;border-radius:10px;font-weight:700;z-index:1000">${msg}</div>`;
  setTimeout(()=> overlay.innerHTML = '', 1500);
}

function shade(hex, percent){
  const c = hex.replace('#',''); const num = parseInt(c,16);
  const r = Math.min(255, Math.floor(((num >> 16) & 0xff) * (1+percent)));
  const g = Math.min(255, Math.floor(((num >> 8) & 0xff) * (1+percent)));
  const b = Math.min(255, Math.floor(((num) & 0xff) * (1+percent)));
  return `rgb(${r},${g},${b})`;
}

/* -----------------------
   Input handling (mouse & touch & keyboard)
   ----------------------- */
let pointer = {x:0,y:0,down:false};
const rectCache = () => canvas.getBoundingClientRect();

canvas.addEventListener('mousemove', (e)=> {
  const rect = rectCache(); pointer.x = e.clientX - rect.left; pointer.y = e.clientY - rect.top;
  updateAim();
});
canvas.addEventListener('touchmove', (e)=> {
  e.preventDefault();
  const t = e.touches[0]; const rect = rectCache(); pointer.x = t.clientX - rect.left; pointer.y = t.clientY - rect.top; updateAim();
}, {passive:false});
canvas.addEventListener('click', ()=> { shoot(state.shooter.angle); });
document.addEventListener('keydown', (e)=> {
  if(e.code === 'Space'){ e.preventDefault(); shoot(state.shooter.angle); }
  if(e.key === '1') useAbility('wild');
  if(e.key === '2') useAbility('fire');
  if(e.key === '3') useAbility('ice');
});

function updateAim(){
  const sx = CANVAS_W/2, sy = CANVAS_H - 60;
  const dx = pointer.x - sx, dy = pointer.y - sy;
  let angle = Math.atan2(dy, dx);
  // clamp to upper half
  const min = -Math.PI + 0.2, max = -0.2;
  angle = clamp(angle, min, max);
  state.shooter.angle = angle;
}

/* abilities */
function useAbility(name){
  if(state.abilities[name] <= 0){ toast('No ' + name + ' available'); return; }
  // consume and set next ball special
  state.abilities[name]--;
  if(name === 'wild'){ state.shooter.ball = {color: 0, special:'wild'}; toast('Wild ready: next shot'); }
  if(name === 'fire'){ state.shooter.ball = {color: 0, special:'fire'}; toast('Fireball ready: next shot'); }
  if(name === 'ice'){ state.shooter.ball = {color: 0, special:'ice'}; toast('Ice ready: next shot'); }
  saveProgress();
}

/* -----------------------
   UI wiring
   ----------------------- */
document.getElementById('btnWild').addEventListener('click', ()=> useAbility('wild'));
document.getElementById('btnFire').addEventListener('click', ()=> useAbility('fire'));
document.getElementById('btnIce').addEventListener('click', ()=> useAbility('ice'));
document.getElementById('btnNext').addEventListener('click', ()=> loadLevel(Math.min(TOTAL_LEVELS, state.level + 1), 1));
document.getElementById('btnPrev').addEventListener('click', ()=> loadLevel(Math.max(1, state.level - 1)));
document.getElementById('btnReset').addEventListener('click', ()=> {
  if(confirm('Reset progress to level 1 and clear saved data?')){ localStorage.removeItem(SAVE_KEY); state = Object.assign(state, {level:1,unlocked:1,score:0,abilities:{wild:1,fire:1,ice:1}}); loadLevel(1); }
});
document.getElementById('addRowEvery').addEventListener('change', (e)=> state.addRowEvery = Number(e.target.value));
document.getElementById('deviceMode').addEventListener('change', (e)=> applyDeviceMode(e.target.value));
document.getElementById('dayToggle').addEventListener('click', ()=> {
  isDay = !isDay;
  document.body.classList.toggle('theme-light', isDay);
  document.body.classList.toggle('theme-dark', !isDay);
  document.getElementById('dayToggle').textContent = isDay ? '☀️' : '🌙';
  resizeCanvas();
});

/* initial load & responsiveness */
loadProgress();
applyDeviceMode('auto'); // will pick sizes based on container
loadLevel(state.level);
updateNextQueueUI();

/* show next queue initially */
(function initQueueUI(){ updateNextQueueUI(); })();

/* -----------------------
   Start the game loop & helpers
   ----------------------- */
function start(){
  lastFrame = performance.now();
  requestAnimationFrame(gameLoop);
}
start();

/* small utilities */
function countRemaining(){ return currentLevel ? countGrid(currentLevel.grid) : 0; }

/* End of script */
</script>
</body>
</html>
