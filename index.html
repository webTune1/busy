<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Arcade — Ludo + Quiz + Puzzle</title>
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --accent:#ffb86b;
    --muted:#94a3b8;
    --glass: rgba(255,255,255,0.03);
    --success:#10b981;
    --danger:#ef4444;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:
    radial-gradient(circle at 10% 10%, rgba(255,184,107,0.06), transparent 8%),
    linear-gradient(180deg,#071029 0%, #081226 60%); color:#e6eef8;}
  .app{
    max-width:1100px;margin:24px auto;padding:20px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
    border:1px solid rgba(255,255,255,0.03);
  }
  header{display:flex;align-items:center;gap:16px;margin-bottom:18px}
  header h1{margin:0;font-size:20px}
  .tabs{display:flex;gap:8px;margin-left:auto}
  .tab{padding:8px 12px;border-radius:8px;background:var(--glass);cursor:pointer;color:var(--muted)}
  .tab.active{background:linear-gradient(90deg, rgba(255,184,107,0.14), rgba(255,255,107,0.06));color:var(--accent);font-weight:600}
  .row{display:flex;gap:18px}
  .col{flex:1;min-width:260px}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,0.02)}
  #boardWrap{display:flex;flex-direction:column;align-items:center;gap:10px}
  canvas{background:transparent;border-radius:12px}
  .controls{display:flex;gap:8px;align-items:center;margin-top:6px}
  button{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);color:var(--accent);padding:8px 12px;border-radius:8px;cursor:pointer}
  button.ghost{background:transparent;color:var(--muted);border:1px dashed rgba(255,255,255,0.03)}
  .small{padding:6px 8px;font-size:13px}
  .log{max-height:120px;overflow:auto;padding:8px;border-radius:8px;background:rgba(0,0,0,0.2);font-size:13px;color:var(--muted)}
  .players{display:flex;gap:8px;flex-wrap:wrap}
  .playerSetup{display:flex;gap:8px;align-items:center}
  select,input[type=number]{padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}
  .dice{width:62px;height:62px;border-radius:10px;background:linear-gradient(180deg,#123445,#0b2b3a);display:flex;align-items:center;justify-content:center;font-size:22px;font-weight:700;color:#fff;box-shadow:inset 0 2px 8px rgba(0,0,0,0.4)}
  .badge{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;font-size:13px;color:var(--muted)}
  .center{display:flex;justify-content:center;align-items:center}
  .modeBox{display:flex;gap:8px;align-items:center}
  .muted{color:var(--muted);font-size:13px}
  /* Quiz styles */
  .quiz qwrap{display:block}
  .question{font-size:16px;margin-bottom:8px}
  .answers{display:flex;flex-direction:column;gap:8px}
  .answer{padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);cursor:pointer}
  .answer.correct{border:2px solid var(--success);background:linear-gradient(90deg, rgba(16,185,129,0.06), rgba(16,185,129,0.02))}
  .answer.wrong{border:2px solid var(--danger);background:linear-gradient(90deg, rgba(239,68,68,0.06), rgba(239,68,68,0.02))}
  /* Puzzle styles */
  #puzzleBoard{display:grid;gap:4px;background:linear-gradient(180deg,#071428,#0a1b2a);padding:12px;border-radius:12px}
  .tile{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#0f2130,#0b1220);color:var(--accent);font-weight:700;border-radius:6px;user-select:none;cursor:pointer;border:1px solid rgba(255,255,255,0.03)}
  .hidden{background:transparent;border:0;cursor:default}
  footer{margin-top:14px;font-size:13px;color:var(--muted);display:flex;justify-content:space-between;align-items:center}
  @media (max-width:800px){
    .row{flex-direction:column}
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <div style="display:flex;align-items:center;gap:12px">
      <svg width="36" height="36" viewBox="0 0 24 24" fill="none"><rect x="1" y="1" width="22" height="22" rx="6" fill="#ffb86b" opacity="0.12"/><path d="M7 8h10M7 12h6M7 16h4" stroke="#ffb86b" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
      <div>
        <h1>Mini Arcade — Ludo • Quiz • Puzzle</h1>
        <div class="muted">Ludo focus with bots, pass‑and‑play, shuffled quiz and sliding puzzle</div>
      </div>
    </div>
    <div class="tabs" role="tablist">
      <div class="tab active" id="tab-ludo" data-tab="ludo">Ludo</div>
      <div class="tab" id="tab-quiz" data-tab="quiz">Quiz</div>
      <div class="tab" id="tab-puzzle" data-tab="puzzle">Puzzle (20+ min)</div>
    </div>
  </header>

  <div id="ludo" class="row content">
    <div class="col card">
      <div id="boardWrap" class="center">
        <canvas id="board" width="560" height="560"></canvas>
        <div class="controls">
          <div class="badge">Turn: <span id="turnLabel">—</span></div>
          <div class="dice" id="diceDisplay">—</div>
          <button id="rollBtn">Roll Dice</button>
          <button id="moveBtn" class="ghost small">Auto Move</button>
          <button id="newGameBtn" class="small">New Game</button>
        </div>
      </div>
    </div>
    <div class="col card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>Players</strong><div class="muted">Choose human or bot</div></div>
        <div class="modeBox">
          <label class="muted">Bots:</label>
          <select id="botDifficulty">
            <option value="1">Easy</option>
            <option value="2" selected>Medium</option>
            <option value="3">Hard</option>
          </select>
        </div>
      </div>
      <div style="margin-top:10px" class="players" id="playersSetup">
        <!-- Player setup entries populated by JS -->
      </div>

      <hr style="border:none;height:8px;background:transparent">

      <div><strong>Game Log</strong></div>
      <div class="log" id="log"></div>

      <div style="margin-top:10px;display:flex;gap:8px;justify-content:space-between">
        <div class="muted">Rules: roll a 6 to move out. Capture opponent by landing on them. Safe squares marked with dot. Extra turn on 6.</div>
        <div>
          <button id="saveBtn" class="ghost small">Save</button>
          <button id="loadBtn" class="ghost small">Load</button>
        </div>
      </div>
    </div>
  </div>

  <div id="quiz" class="row content" style="display:none">
    <div class="col card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>Quick Quiz</strong><div class="muted">Randomized questions and answers</div></div>
        <div><span class="badge">Score: <span id="quizScore">0</span></span></div>
      </div>
      <div style="margin-top:12px">
        <div class="question" id="qText"></div>
        <div class="answers" id="answers"></div>
      </div>
      <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
        <button id="nextQ" class="small ghost">Next Question</button>
        <button id="startQuiz" class="small">Start New Quiz</button>
        <div class="muted" style="margin-left:auto">Q left: <span id="qLeft">0</span></div>
      </div>
    </div>
    <div class="col card">
      <strong>Settings</strong>
      <div style="margin-top:8px">
        <label class="muted">Questions per session</label><br>
        <input id="qCount" type="number" value="10" min="3" max="50" />
      </div>
      <div style="margin-top:12px">
        <strong>Question Bank</strong>
        <div class="muted" style="font-size:13px;margin-top:8px">The quiz uses an embedded pool and shuffles each session so questions differ each time.</div>
      </div>
    </div>
  </div>

  <div id="puzzle" class="row content" style="display:none">
    <div class="col card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <strong>Sliding Puzzle</strong>
          <div class="muted">Solve the 6x6 sliding puzzle. Designed to be long — use hints sparingly.</div>
        </div>
        <div class="muted">Elapsed: <span id="pTime">00:00</span></div>
      </div>
      <div style="margin-top:12px" id="puzzleBoardWrap" class="center">
        <div id="puzzleBoard"></div>
      </div>
      <div style="margin-top:10px;display:flex;gap:8px">
        <button id="shufflePuzzle" class="small">Shuffle</button>
        <button id="hintBtn" class="small ghost">Show Hint</button>
        <button id="solveBtn" class="small ghost">Auto Solve (demo)</button>
      </div>
      <div style="margin-top:10px" class="muted">Tip: use the hint to reveal the correct position of one tile. Hints reduce score/time reward.</div>
    </div>
    <div class="col card">
      <strong>Puzzle Settings</strong>
      <div style="margin-top:8px">
        <label class="muted">Grid size</label><br>
        <select id="pSize">
          <option value="4">4 x 4</option>
          <option value="5">5 x 5</option>
          <option value="6" selected>6 x 6 (recommended)</option>
        </select>
      </div>
      <div style="margin-top:12px">
        <strong>Progress</strong>
        <div class="muted" id="pStatus">Not started</div>
      </div>
    </div>
  </div>

  <footer>
    <div>Built for web — open, free, and local-only. Want online matches or a native app? I can add that next.</div>
    <div>&copy; Mini Arcade</div>
  </footer>
</div>

<script>
/*
  Mini Arcade Single-file app
  - Ludo: pass-and-play + bots (local only)
  - Quiz: randomized bank
  - Puzzle: sliding puzzle with timer and hint
  Basic but complete and usable as a single index.html.
*/

/* ---------------------------
   Utility helpers
----------------------------*/
const $ = v => document.querySelector(v);
const $$ = v => Array.from(document.querySelectorAll(v));
const rand = (n)=>Math.floor(Math.random()*n);
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){let j=rand(i+1);[arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
function fmtTime(s){ const m=Math.floor(s/60), sec=s%60; return String(m).padStart(2,'0')+':'+String(sec).padStart(2,'0'); }

/* ---------------------------
   Tab switching
----------------------------*/
const tabs = $$('.tab');
tabs.forEach(t=>t.addEventListener('click',ev=>{
  tabs.forEach(x=>x.classList.remove('active'));
  t.classList.add('active');
  const tab = t.dataset.tab;
  $$('.content').forEach(c=>c.style.display='none');
  $('#'+tab).style.display='flex';
}));

/* =========================================================
   LUDO Implementation (simplified, standard rules)
   - track of 52 main squares (0..51)
   - each color has 4 tokens, base = -1, home path indexes 52..57 (6 steps to finish)
   - start indexes: Red 0, Green 13, Yellow 26, Blue 39 (clockwise)
   - safe squares are starting squares + some fixed ones
   - drawing uses canvas coordinates computed programmatically
   ========================================================= */
const canvas = $('#board');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const CENTER = {x:W/2, y:H/2};
const RADIUS = Math.min(W,H)/2 - 36;

const COLORS = ['red','green','yellow','blue'];
const colorHex = {red:'#f43f5e', green:'#10b981', yellow:'#f59e0b', blue:'#3b82f6'};
const START_INDEX = {red:0, green:13, yellow:26, blue:39};

let gameState = null;
let savedState = null;

function newGame(config){
  // config: players array of {type:'human'|'bot',name}
  const players = config.players;
  gameState = {
    players: players,
    activeIndex: 0,
    dice: null,
    rolled: false,
    positions: players.map(()=>[-1,-1,-1,-1]), // -1 base, >=0 on board or homePath indices (>=52 for home)
    finished: players.map(()=>false),
    winners: []
  };
  log('New game started. Players: ' + players.map(p=>p.name + (p.type==='bot'?' (bot)':'')).join(', '));
  drawBoard();
  updateUI();
}

function saveGame(){
  savedState = JSON.stringify(gameState);
  log('Game saved locally (in memory).');
}
function loadGame(){
  if(!savedState){ log('No saved game found.'); return; }
  gameState = JSON.parse(savedState);
  log('Saved game loaded.');
  drawBoard(); updateUI();
}

/* Helper: convert logical position to absolute coordinates for drawing.
   We'll make 52 points around a circle for simplicity. Home paths are radial inward positions.
*/
const MAIN_COUNT = 52;
let mainCoords = [];
(function computeCoords(){
  mainCoords = [];
  for(let i=0;i<MAIN_COUNT;i++){
    const angle = -Math.PI/2 + (i / MAIN_COUNT) * (Math.PI*2);
    const r = RADIUS;
    mainCoords.push({
      x: CENTER.x + Math.cos(angle) * r,
      y: CENTER.y + Math.sin(angle) * r
    });
  }
})();

function homeCoord(color, step){ // step 0..5 -> closer to center
  const start = START_INDEX[color];
  const angle = -Math.PI/2 + (start / MAIN_COUNT) * (Math.PI*2);
  const startR = RADIUS - 42;
  const r = startR - (step+1)*28;
  return {x:CENTER.x + Math.cos(angle)*r, y:CENTER.y + Math.sin(angle)*r};
}

function drawBoard(){
  ctx.clearRect(0,0,W,H);
  // background circle
  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.beginPath(); ctx.arc(CENTER.x,CENTER.y,RADIUS+18,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();
  ctx.restore();

  // draw main path dots
  for(let i=0;i<MAIN_COUNT;i++){
    const p = mainCoords[i];
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.arc(p.x,p.y,18,0,Math.PI*2); ctx.fill();
    // safe dot if it's a start position
    if(Object.values(START_INDEX).includes(i)){
      ctx.beginPath();
      ctx.fillStyle = '#fff'; ctx.globalAlpha=0.08; ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    }
  }
  // center decoration
  ctx.beginPath();
  ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.arc(CENTER.x,CENTER.y,68,0,Math.PI*2); ctx.fill();

  // draw tokens
  if(!gameState) return;
  const positions = gameState.positions;
  for(let pi=0;pi<positions.length;pi++){
    const color = COLORS[pi];
    for(let t=0;t<4;t++){
      const pos = positions[pi][t];
      let cx,cy;
      if(pos === -1){ // base cluster
        const offset = tokenBaseOffset(pi,t);
        cx = CENTER.x + offset.x;
        cy = CENTER.y + offset.y;
      } else if(pos >= 0 && pos < MAIN_COUNT){
        const p = mainCoords[pos];
        cx = p.x; cy = p.y;
      } else {
        // home zone pos from 52..57 => convert to step 0..5
        const step = pos - 52;
        const p = homeCoord(color, step);
        cx = p.x; cy = p.y;
      }
      drawToken(cx,cy,color,t);
    }
  }
}

function tokenBaseOffset(playerIndex, tokenIndex){
  // place 4 tokens in a square around center for each player with offsets
  const off = 120;
  const mapping = {
    0: [{x:-off,y:-off},{x:-off+48,y:-off},{x:-off,y:-off+48},{x:-off+48,y:-off+48}], // red top-left
    1: [{x:off,y:-off},{x:off-48,y:-off},{x:off,y:-off+48},{x:off-48,y:-off+48}],     // green top-right
    2: [{x:off,y:off},{x:off-48,y:off},{x:off,y:off-48},{x:off-48,y:off-48}],         // yellow bottom-right
    3: [{x:-off,y:off},{x:-off+48,y:off},{x:-off,y:off-48},{x:-off+48,y:off-48}]      // blue bottom-left
  };
  return mapping[playerIndex][tokenIndex];
}

function drawToken(x,y,color,idx){
  ctx.beginPath();
  ctx.fillStyle = colorHex[color] || '#aaa';
  ctx.shadowColor = 'rgba(0,0,0,0.6)'; ctx.shadowBlur=8; ctx.shadowOffsetY=4;
  ctx.arc(x,y,14,0,Math.PI*2); ctx.fill();
  ctx.shadowBlur=0; ctx.shadowOffsetY=0;
  ctx.beginPath();
  ctx.fillStyle = '#fff'; ctx.font='11px Inter'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(String(idx+1), x, y);
}

function log(msg){
  const d = new Date().toLocaleTimeString();
  const el = $('#log');
  el.innerHTML = `<div>[${d}] ${msg}</div>` + el.innerHTML;
}

/* Game logic helpers */
function playerColor(index){
  return COLORS[index];
}
function nextTurn(){
  if(!gameState) return;
  // find next active player who hasn't finished
  const n = gameState.players.length;
  let i = gameState.activeIndex;
  for(let k=1;k<=n;k++){
    const next = (i + k) % n;
    if(!gameState.finished[next]){ gameState.activeIndex = next; break; }
  }
  gameState.rolled = false;
  gameState.dice = null;
  updateUI();
}

/* move token by steps: token position may be -1 (base) */
function moveToken(playerIndex, tokenIndex, steps){
  const posArr = gameState.positions[playerIndex];
  let pos = posArr[tokenIndex];
  const startIndex = START_INDEX[playerColor(playerIndex)];
  if(pos === -1){
    if(steps === 6){
      posArr[tokenIndex] = startIndex; // move out onto board
      log(`${gameState.players[playerIndex].name} moved token ${tokenIndex+1} out of base.`);
    } else {
      // invalid
      return false;
    }
  } else {
    // compute linear progress relative to player's start
    let relative = (pos - startIndex + MAIN_COUNT) % MAIN_COUNT;
    let newRel = relative + steps;
    if(newRel >= 51){ // reaching home path (we'll use simple rule: positions >=51 go into home steps)
      const homeStep = newRel - 51; // 0..5
      if(homeStep <= 5){
        posArr[tokenIndex] = 52 + homeStep;
      } else {
        // overshoot -> invalid
        return false;
      }
    } else {
      const newPos = (startIndex + newRel) % MAIN_COUNT;
      posArr[tokenIndex] = newPos;
    }
    log(`${gameState.players[playerIndex].name} moved token ${tokenIndex+1} by ${steps}.`);
  }
  // check captures (only on main board)
  captureAt(playerIndex, posArr[tokenIndex]);
  // check finish
  if(posArr.every(p=>p>=52 && p<=57)){
    gameState.finished[playerIndex] = true;
    gameState.winners.push(gameState.players[playerIndex].name);
    log(`${gameState.players[playerIndex].name} reached home!`);
  }
  drawBoard();
  return true;
}

function captureAt(playerIndex, pos){
  if(pos >=0 && pos < MAIN_COUNT){
    // if any other player's token at same pos -> send them to base
    for(let pi=0;pi<gameState.positions.length;pi++){
      if(pi===playerIndex) continue;
      for(let ti=0;ti<4;ti++){
        if(gameState.positions[pi][ti] === pos){
          // check safe squares: starting squares are safe
          if(Object.values(START_INDEX).includes(pos)) {
            log(`Position ${pos} is safe. No capture.`);
            continue;
          }
          gameState.positions[pi][ti] = -1;
          log(`${gameState.players[playerIndex].name} captured ${gameState.players[pi].name}'s token ${ti+1}!`);
        }
      }
    }
  }
}

/* get legal moves for current player given dice */
function legalMovesFor(playerIndex, roll){
  const posArr = gameState.positions[playerIndex];
  const moves = [];
  for(let t=0;t<4;t++){
    const pos = posArr[t];
    if(pos === -1){
      if(roll === 6) moves.push({token:t,from:-1,to:START_INDEX[playerColor(playerIndex)]});
    } else {
      // compute prospective move
      const startIndex = START_INDEX[playerColor(playerIndex)];
      let relative = (pos - startIndex + MAIN_COUNT) % MAIN_COUNT;
      let newRel = relative + roll;
      if(newRel >= 51){
        const homeStep = newRel - 51;
        if(homeStep <= 5) moves.push({token:t, from:pos, to:52+homeStep});
      } else {
        moves.push({token:t, from:pos, to:(startIndex + newRel) % MAIN_COUNT});
      }
    }
  }
  return moves;
}

/* bot logic: difficulty levels
  1 (easy): random legal move
  2 (medium): prefer capture > move out > move closer to home
  3 (hard): like medium but avoid moves that put token on immediate capture spot (basic risk)
*/
function botChooseMove(playerIndex, roll, difficulty){
  const moves = legalMovesFor(playerIndex, roll);
  if(moves.length===0) return null;
  if(difficulty==1) return moves[rand(moves.length)];
  // check capture moves
  for(const m of moves){
    if(m.to>=0 && m.to<MAIN_COUNT){
      for(let pi=0;pi<gameState.positions.length;pi++){
        if(pi===playerIndex) continue;
        for(let ti=0;ti<4;ti++){
          if(gameState.positions[pi][ti] === m.to && !Object.values(START_INDEX).includes(m.to)){
            return m;
          }
        }
      }
    }
  }
  // prefer moving out of base
  for(const m of moves) if(m.from===-1) return m;
  // prefer larger progress (closer to home)
  moves.sort((a,b)=>{
    const prog = (a.to>=52)?1000:((a.to - START_INDEX[playerColor(playerIndex)] + MAIN_COUNT)%MAIN_COUNT);
    const prog2 = (b.to>=52)?1000:((b.to - START_INDEX[playerColor(playerIndex)] + MAIN_COUNT)%MAIN_COUNT);
    return prog2-prog; // descending prefer bigger progress
  });
  if(difficulty==3){
    // avoid moves that land where opponent can immediately capture (naive: check any opponent with roll 6 landing on this spot)
    for(const m of moves){
      let safe=true;
      for(let pi=0;pi<gameState.positions.length;pi++){
        if(pi===playerIndex) continue;
        for(let ti=0;ti<4;ti++){
          const oppPos = gameState.positions[pi][ti];
          if(oppPos===-1) continue;
          // if opponent can reach m.to in one roll of 6: compute distance from oppPos to m.to along main track
          if(m.to>=0 && m.to<MAIN_COUNT && oppPos>=0 && oppPos<MAIN_COUNT){
            const dist = (m.to - oppPos + MAIN_COUNT) % MAIN_COUNT;
            if(dist<=6){ safe=false; break; }
          }
        }
        if(!safe) break;
      }
      if(safe) return m;
    }
  }
  return moves[0];
}

/* UI wiring */
function updateUI(){
  if(!gameState) return;
  $('#turnLabel').textContent = gameState.players[gameState.activeIndex].name;
  $('#diceDisplay').textContent = gameState.dice===null? '—' : gameState.dice;
  $('#rollBtn').disabled = gameState.rolled;
  $('#moveBtn').disabled = !gameState.rolled;
  // player setup view reflect players
  const wrap = $('#playersSetup');
  wrap.innerHTML = '';
  gameState.players.forEach((p, i)=>{
    const div = document.createElement('div'); div.className='playerSetup';
    div.innerHTML = `<div style="width:12px;height:12px;border-radius:3px;background:${colorHex[COLORS[i]]};margin-right:6px"></div>
      <div style="min-width:120px">${p.name} ${p.type==='bot'?'<span class="muted">(bot)</span>':''}</div>
      <div class="muted">Score:—</div>`;
    wrap.appendChild(div);
  });
}

/* Roll dice */
function rollDice(){
  if(!gameState) return;
  const roll = Math.floor(Math.random()*6)+1;
  gameState.dice = roll;
  gameState.rolled = true;
  $('#diceDisplay').textContent = roll;
  log(`${gameState.players[gameState.activeIndex].name} rolled a ${roll}.`);
  drawBoard();
  // if current player is bot, auto choose
  const cur = gameState.activeIndex;
  if(gameState.players[cur].type==='bot'){
    setTimeout(()=>botPerformTurn(cur, roll), 700);
  }
}

function botPerformTurn(index, roll){
  const difficulty = Number($('#botDifficulty').value);
  const choice = botChooseMove(index, roll, difficulty);
  if(choice) {
    moveToken(index, choice.token, roll);
  } else {
    log(`${gameState.players[index].name} has no valid moves.`);
  }
  // if roll was 6, they get another turn (unless finished)
  if(roll===6 && !gameState.finished[index]){
    log(`${gameState.players[index].name} rolled 6 and goes again.`);
    gameState.rolled = false;
    gameState.dice = null;
    drawBoard(); updateUI();
    setTimeout(()=>{ if(gameState.players[index].type==='bot') { const r = Math.floor(Math.random()*6)+1; gameState.dice=r; gameState.rolled=true; botPerformTurn(index,r);} }, 500);
  } else {
    nextTurn();
  }
}

/* User auto move: choose best move for human (helper) */
function autoMoveHuman(){
  const cur = gameState.activeIndex;
  const roll = gameState.dice;
  if(!gameState.rolled) return;
  const moves = legalMovesFor(cur, roll);
  if(moves.length===0){ log('No legal moves'); nextTurn(); return; }
  // pick best by simple heuristic: capture > move out > furthest progress
  let best=null;
  for(const m of moves){
    // detect capture
    if(m.to>=0 && m.to<MAIN_COUNT){
      for(let pi=0;pi<gameState.positions.length;pi++){
        if(pi===cur) continue;
        for(let ti=0;ti<4;ti++){
          if(gameState.positions[pi][ti]===m.to && !Object.values(START_INDEX).includes(m.to)) { best=m; break; }
        }
        if(best) break;
      }
    }
    if(best) break;
  }
  if(!best){
    for(const m of moves) if(m.from===-1){ best=m; break; }
  }
  if(!best){
    moves.sort((a,b)=>{
      const progA = (a.to>=52)?1000:((a.to - START_INDEX[playerColor(cur)] + MAIN_COUNT)%MAIN_COUNT);
      const progB = (b.to>=52)?1000:((b.to - START_INDEX[playerColor(cur)] + MAIN_COUNT)%MAIN_COUNT);
      return progB-progA;
    });
    best = moves[0];
  }
  moveToken(cur, best.token, roll);
  if(roll===6 && !gameState.finished[cur]){ gameState.rolled=false; gameState.dice=null; drawBoard(); updateUI(); } else { nextTurn(); }
}

/* Setup initial players selection UI for new game */
function openNewGameDialog(){
  // build a default: 4 players, first human, others bots/human as configured
  const container = $('#playersSetup');
  container.innerHTML='';
  for(let i=0;i<4;i++){
    const color = COLORS[i];
    const div = document.createElement('div');
    div.className='playerSetup';
    div.innerHTML = `
      <div style="width:12px;height:12px;border-radius:3px;background:${colorHex[color]};margin-right:6px"></div>
      <input type="text" value="${color[0].toUpperCase()+color.slice(1)}" data-index="${i}" style="width:110px" />
      <select data-index="${i}">
        <option value="human">Human</option>
        <option value="bot">Bot</option>
      </select>
    `;
    container.appendChild(div);
  }
}

/* Hook UI events */
$('#newGameBtn').addEventListener('click',()=>{
  // gather player config from playersSetup if present
  const selects = $('#playersSetup').querySelectorAll('select');
  const inputs = $('#playersSetup').querySelectorAll('input[type=text]');
  const players = [];
  if(selects.length && inputs.length){
    for(let i=0;i<selects.length;i++){
      players.push({name:inputs[i].value || `Player ${i+1}`, type: selects[i].value});
    }
  } else {
    // default
    players.push({name:'You',type:'human'},{name:'Bot 1',type:'bot'},{name:'Bot 2',type:'bot'},{name:'Bot 3',type:'bot'});
  }
  newGame({players});
});
$('#rollBtn').addEventListener('click',()=>rollDice());
$('#moveBtn').addEventListener('click',()=>autoMoveHuman());
$('#saveBtn').addEventListener('click',()=>saveGame());
$('#loadBtn').addEventListener('click',()=>loadGame());
$('#playersSetup').addEventListener('change',()=>{ /* no-op, inputs captured on new game */ });

/* init: show new game default */
openNewGameDialog();
newGame({players:[{name:'You',type:'human'},{name:'Bot 1',type:'bot'},{name:'Bot 2',type:'bot'},{name:'Bot 3',type:'bot'}]});

/* =========================================================
   QUIZ Implementation (randomized bank)
   ========================================================= */
const QUESTION_BANK = [
  {q:"What is the capital of France?", a:["Paris","Berlin","Rome","Madrid"], correct:0},
  {q:"Which planet is known as the Red Planet?", a:["Mars","Venus","Jupiter","Saturn"], correct:0},
  {q:"Who wrote 'Romeo and Juliet'?", a:["Shakespeare","Dickens","Hemingway","Tolstoy"], correct:0},
  {q:"What is 7 x 8?", a:["56","54","48","49"], correct:0},
  {q:"Which element has symbol O?", a:["Oxygen","Gold","Iron","Hydrogen"], correct:0},
  {q:"What year did the first man land on the Moon?", a:["1969","1959","1979","1989"], correct:0},
  {q:"What currency is used in Japan?", a:["Yen","Dollar","Euro","Won"], correct:0},
  {q:"What is the largest ocean on Earth?", a:["Pacific","Atlantic","Indian","Arctic"], correct:0},
  {q:"Who painted the Mona Lisa?", a:["Leonardo da Vinci","Van Gogh","Picasso","Rembrandt"], correct:0},
  {q:"Which language powers most webpages?", a:["JavaScript","Python","C++","Ruby"], correct:0},
  {q:"Which gas do plants mainly use for photosynthesis?", a:["Carbon dioxide","Oxygen","Nitrogen","Helium"], correct:0},
  {q:"What is H2O commonly known as?", a:["Water","Hydrogen peroxide","Salt","Alcohol"], correct:0},
  {q:"Which continent is Egypt in?", a:["Africa","Asia","Europe","South America"], correct:0},
  {q:"Who discovered penicillin?", a:["Alexander Fleming","Louis Pasteur","Marie Curie","Gregor Mendel"], correct:0},
  {q:"What is the boiling point of water at sea level (°C)?", a:["100","90","80","70"], correct:0},
  {q:"What color do you get by mixing red and blue?", a:["Purple","Green","Orange","Brown"], correct:0},
  {q:"Which instrument has keys, pedals and strings?", a:["Piano","Guitar","Drums","Trumpet"], correct:0},
  {q:"Which is the smallest prime number?", a:["2","1","3","5"], correct:0},
  {q:"What is the chemical symbol for gold?", a:["Au","Ag","Gd","Go"], correct:0},
  {q:"What is the largest land animal?", a:["Elephant","Giraffe","Rhino","Hippo"], correct:0},
  // add more if desired
];

let quizState = {pool:[],index:0,score:0,sessionSize:10};

function startQuiz(){
  const size = Math.max(3, Math.min(50, Number($('#qCount').value || 10)));
  quizState.sessionSize = size;
  const pool = [...QUESTION_BANK];
  shuffle(pool);
  quizState.pool = pool.slice(0,size).map(q=>{
    return {...q, shuffledAnswers: shuffle(q.a.map((t,i)=>({text:t,idx:i})))};
  });
  quizState.index = 0; quizState.score = 0;
  $('#quizScore').textContent = '0';
  $('#qLeft').textContent = quizState.sessionSize - quizState.index;
  showQuestion();
  log('Quiz started: ' + size + ' questions.');
}

function showQuestion(){
  const q = quizState.pool[quizState.index];
  if(!q){ $('#qText').textContent='No more questions'; $('#answers').innerHTML=''; $('#qLeft').textContent='0'; return; }
  $('#qText').textContent = (quizState.index+1) + '. ' + q.q;
  const answersWrap = $('#answers'); answersWrap.innerHTML='';
  q.shuffledAnswers.forEach(opt=>{
    const btn = document.createElement('div'); btn.className='answer';
    btn.textContent = opt.text;
    btn.addEventListener('click',()=>{
      if(btn.classList.contains('answered')) return;
      btn.classList.add('answered');
      if(opt.idx === q.correct){
        btn.classList.add('correct'); quizState.score++; $('#quizScore').textContent = quizState.score;
        log('Quiz: correct answer.');
      } else {
        btn.classList.add('wrong');
        // highlight correct
        [...answersWrap.children].forEach(c=>{
          if(c.textContent === q.a[q.correct]) c.classList.add('correct');
        });
        log('Quiz: wrong answer.');
      }
      // disable others
      [...answersWrap.children].forEach(c=>c.style.pointerEvents='none');
      $('#qLeft').textContent = quizState.sessionSize - (quizState.index+1);
    });
    answersWrap.appendChild(btn);
  });
}

$('#startQuiz').addEventListener('click',()=>startQuiz());
$('#nextQ').addEventListener('click',()=>{
  quizState.index++;
  if(quizState.index >= quizState.sessionSize){ alert('Quiz finished. Score: '+quizState.score+'/'+quizState.sessionSize); return; }
  showQuestion();
});

/* =========================================================
   Sliding Puzzle Implementation
   - grid NxN, numbers 1..N*N-1 and one empty
   - shuffle and allow clicks to slide; timer; hint reveals position of one tile
   ========================================================= */
let puzzle = {size:6, tiles:[], emptyIndex:0, started:false, startTime:0, elapsed:0, timer:null, hints:0};

function buildPuzzle(size){
  puzzle.size = size;
  const n = size*size;
  puzzle.tiles = [];
  for(let i=1;i<n;i++) puzzle.tiles.push(i);
  puzzle.tiles.push(null); // empty
  puzzle.emptyIndex = n-1;
  puzzle.started=false; puzzle.elapsed=0; puzzle.hints=0;
  renderPuzzle();
}

function renderPuzzle(){
  const board = $('#puzzleBoard');
  const n = puzzle.size;
  board.style.gridTemplateColumns = `repeat(${n}, 1fr)`;
  board.style.width = Math.min(420, n*72) + 'px';
  board.style.height = Math.min(420, n*72) + 'px';
  board.innerHTML = '';
  for(let i=0;i<puzzle.tiles.length;i++){
    const val = puzzle.tiles[i];
    const div = document.createElement('div');
    div.className='tile' + (val===null? ' hidden':'');
    if(val !== null) div.textContent = val;
    div.style.fontSize = Math.max(12, 28 - puzzle.size) + 'px';
    div.addEventListener('click',()=>onTileClick(i));
    board.appendChild(div);
  }
  $('#pStatus').textContent = puzzle.started ? `Started — hints used ${puzzle.hints}` : 'Not started';
}

function onTileClick(index){
  // attempt to move tile into empty if adjacent
  const size = puzzle.size;
  const r = Math.floor(index/size), c = index%size;
  const er = Math.floor(puzzle.emptyIndex/size), ec = puzzle.emptyIndex%size;
  const dist = Math.abs(r-er) + Math.abs(c-ec);
  if(dist===1){
    [puzzle.tiles[index], puzzle.tiles[puzzle.emptyIndex]] = [puzzle.tiles[puzzle.emptyIndex], puzzle.tiles[index]];
    puzzle.emptyIndex = index;
    renderPuzzle();
    if(!puzzle.started){ puzzle.started=true; startPuzzleTimer(); $('#pStatus').textContent='Started'; }
    checkPuzzleComplete();
  }
}

function shufflePuzzle(steps=400){
  // perform random legal moves from solved state
  buildPuzzle(puzzle.size);
  let last = -1;
  for(let i=0;i<steps;i++){
    const neighbors = getNeighbors(puzzle.emptyIndex);
    // avoid undo
    const choice = neighbors[rand(neighbors.length)];
    [puzzle.tiles[choice], puzzle.tiles[puzzle.emptyIndex]] = [puzzle.tiles[puzzle.emptyIndex], puzzle.tiles[choice]];
    puzzle.emptyIndex = choice;
  }
  puzzle.started=true; puzzle.hints=0; renderPuzzle(); startPuzzleTimer(); $('#pStatus').textContent='Shuffled';
}

function getNeighbors(index){
  const size = puzzle.size;
  const r = Math.floor(index/size), c = index%size;
  const list=[];
  if(r>0) list.push(index-size);
  if(r<size-1) list.push(index+size);
  if(c>0) list.push(index-1);
  if(c<size-1) list.push(index+1);
  return list;
}

function startPuzzleTimer(){
  puzzle.startTime = Date.now();
  if(puzzle.timer) clearInterval(puzzle.timer);
  puzzle.timer = setInterval(()=>{
    puzzle.elapsed = Math.floor((Date.now()-puzzle.startTime)/1000);
    $('#pTime').textContent = fmtTime(puzzle.elapsed);
  },1000);
}

function checkPuzzleComplete(){
  // solved if numbers in order and last null
  for(let i=0;i<puzzle.tiles.length-1;i++){
    if(puzzle.tiles[i] !== i+1) return false;
  }
  if(puzzle.tiles[puzzle.tiles.length-1] !== null) return false;
  // solved
  clearInterval(puzzle.timer); puzzle.timer=null;
  $('#pStatus').textContent = `Solved in ${fmtTime(puzzle.elapsed)} with ${puzzle.hints} hints.`;
  log(`Puzzle solved in ${fmtTime(puzzle.elapsed)}.`);
  return true;
}

function hintReveal(){
  // find a tile not in correct position and place it correctly (by swapping with current position)
  const n = puzzle.tiles.length;
  for(let i=0;i<n-1;i++){
    if(puzzle.tiles[i] !== i+1){
      // find where the tile that should go to i currently is
      const targetVal = i+1;
      const idx = puzzle.tiles.indexOf(targetVal);
      // swap idx with empty? Instead, move tile into empty by swapping directly with empty (we'll place tile at empty, then swap empty into idx)
      if(idx>=0){
        // swap tile at idx with tile at empty (simple)
        [puzzle.tiles[idx], puzzle.tiles[puzzle.emptyIndex]] = [puzzle.tiles[puzzle.emptyIndex], puzzle.tiles[idx]];
        puzzle.emptyIndex = idx;
        puzzle.hints++;
        renderPuzzle(); $('#pStatus').textContent = `Hint used (${puzzle.hints})`;
        log('Puzzle hint used.');
        return;
      }
    }
  }
  log('No hint available or already solved.');
}

/* Wire puzzle buttons */
$('#shufflePuzzle').addEventListener('click',()=>{ shufflePuzzle(puzzle.size===6?400:200); });
$('#hintBtn').addEventListener('click',()=>{ hintReveal(); });
$('#solveBtn').addEventListener('click',()=>{ // demo solve: reset to solved
  buildPuzzle(puzzle.size); clearInterval(puzzle.timer); puzzle.timer=null; puzzle.elapsed=0; $('#pTime').textContent='00:00';
  renderPuzzle(); $('#pStatus').textContent='Solved (demo)'; log('Puzzle auto-solved (demo).');
});
$('#pSize').addEventListener('change',()=>{ buildPuzzle(Number($('#pSize').value)); });

/* init puzzle */
buildPuzzle(6);

/* initial draw */
drawBoard();

/* Small accessibility: allow keyboard roll space when focused */
document.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ e.preventDefault(); if($('#rollBtn') && !$('#rollBtn').disabled) rollDice(); } });

/* End of app */
</script>
</body>
</html>
